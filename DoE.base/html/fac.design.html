<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Function for full factorial designs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for fac.design {DoE.base}"><tr><td>fac.design {DoE.base}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2> Function for full factorial designs </h2>

<h3>Description</h3>

<p>Function for creating full factorial designs with arbitrary numbers of levels, 
and potentially with blocking
</p>


<h3>Usage</h3>

<pre>
fac.design(nlevels=NULL, nfactors=NULL, factor.names = NULL, 
        replications=1, repeat.only = FALSE, randomize=TRUE, seed=NULL, 
        blocks=1, block.gen=NULL, block.name="Blocks", bbreps=replications, 
        wbreps=1, block.old.behavior=FALSE)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>nlevels</code></td>
<td>
<p> number(s) of levels, vector with <code>nfactors</code> entries or single number; 
can be omitted, if obvious from <code>factor.names</code> </p>
</td></tr>
<tr valign="top"><td><code>nfactors</code></td>
<td>
<p> number of factors, can be omitted if obvious from entries <code>nlevels</code> or <code>factor.names</code> </p>
</td></tr>
<tr valign="top"><td><code>factor.names</code></td>
<td>
<p> if <code>nlevels</code> is given, <code>factor.names</code> can be a character vector of factor names. 
In this case, default factor levels are the numbers from 1 to the number of levels for each factor.<br />
Otherwise it must be a list of vectors with factor levels. 
If the list is named, list names represent factor names, otherwise default factor names are used.
Default factor names are the first elements of the character vector <code><a href="utilities.html">Letters</a></code>, 
or the factors position numbers preceded by capital F in case of more than 50 factors.
If both <code>nlevels</code> and factor.names are 
given, they must be compatible.</p>
</td></tr>
<tr valign="top"><td><code>replications</code></td>
<td>
<p> positive integer number. Default 1 (i.e. each row just once). 
If larger, each design run is executed replication times. 
If <code>repeat.only</code>, repeated measurements 
are carried out directly in sequence, i.e. no true replication takes place, 
and all the repeat runs are conducted together. It is likely that the error 
variation generated by such a procedure will be too small, so that average values 
should be analyzed for an unreplicated design. 
</p>
<p>Otherwise (default), the full experiment is first carried out once, then 
for the second replication and so forth. In case of randomization, 
each such blocks is randomized separately. In this case, replication variance is 
more likely suitable for usage as error variance 
(unless e.g. the same parts are used for replication runs although build 
variation is important).</p>
</td></tr>
<tr valign="top"><td><code>repeat.only</code></td>
<td>
<p> logical, relevant only if replications &gt; 1. If <code>TRUE</code>, 
replications of each run are grouped together 
(repeated measurement rather than true replication). The default is 
<code>repeat.only=FALSE</code>, i.e. the complete experiment 
is conducted in <code>replications</code> blocks, and each run occurs in each block.  </p>
</td></tr>
<tr valign="top"><td><code>randomize</code></td>
<td>
<p> logical. If <code>TRUE</code>, the design is randomized. This is the default. 
In case of replications, the nature of randomization depends on the setting of 
option <code>repeat.only</code>.</p>
</td></tr>
<tr valign="top"><td><code>seed</code></td>
<td>
<p> integer seed for the random number generator <br />
In R version 3.6.0 and later, the default behavior of function <code><a href="../../base/html/sample.html">sample</a></code>
has changed. If you work in a new (i.e., &gt;= 3.6.-0) R version and want to reproduce 
a randomized design from an earlier R version (before 3.6.0), 
you have to change the RNGkind setting by<br />
<code>RNGkind(sample.kind="Rounding")</code><br />
before running function <code>fac.design</code>.<br />
It is recommended to change the setting back to the new recommended way afterwards:<br />
<code>RNGkind(sample.kind="default")</code><br />
For an example, see the documentation of the example data set <code><a href="VSGFS.html">VSGFS</a></code>.
</p>
</td></tr>
<tr valign="top"><td><code>blocks</code></td>
<td>
<p> is the number of blocks into which the experiment is to be subdivided; <br />
it must be a prime or a product of prime numbers which occur as common divisors 
of the numbers of levels of several factors (cf. Details section).<br />
</p>
<p>If the experiment is randomized, randomization happens within blocks. <br />
</p>
</td></tr> 
<tr valign="top"><td><code>block.gen</code></td>
<td>
<p> provides block generating information.<br />
Only specify <code>block.gen</code>, if <code>blocks</code>&gt;1. <br />
If <code>blocks</code> is a prime or a power of 2 (up to 2^8) or 3 (up to 3^5) 
or a product of powers of 2, 3, and an individual other prime, 
<code>block.gen</code> is not needed (but can be optionally specified).<br />
If given, <code>block.gen</code> can be <br />
a numeric vector of integer numbers that will be treated as a one-row matrix <br />
OR a numeric matrix with integer elements.
</p>
<p>There must be a row for each prime number into which <code>blocks</code> factorizes, 
and a column for each (pseudo)factor into which the experimental 
design factors can be partitioned (cf. Details and Examples sections and 
function <code><a href="../../conf.design/html/factorize.html">factorize</a></code>).
</p>
<p>Rows for a p-level contributor to the block factor (p a prime) consist of 
entries 0 to p-1 only.
</p>
</td></tr>
<tr valign="top"><td><code>block.name</code></td>
<td>
<p> name of the block factor, default &ldquo;Blocks&rdquo;</p>
</td></tr>
<tr valign="top"><td><code>bbreps</code></td>
<td>
<p> between block replications; these are always taken as genuine replications, 
not repeat runs; default: equal to <code>replications</code>;
CAUTION: you should not modify <code>bbreps</code> if you do not work with blocks, 
because the program code uses it instead of <code>replications</code> in some places </p>
</td></tr>
<tr valign="top"><td><code>wbreps</code></td>
<td>
<p> within block replications; whether or not these are taken as genuine replications 
depends on the setting of <code>repeat.only</code></p>
</td></tr>
<tr valign="top"><td><code>block.old.behavior</code></td>
<td>
<p>logical that can be used to activate the old (prior 
to version 0.27) behavior of 
blocking full factorial designs; the new behavior is the default, as it 
often creates designs with less severe confounding </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fac.design</code> creates full factorial designs, i.e. the number of runs is the 
product of all numbers of levels.<br /><br />
It is possible to subdivide the design into blocks (one hierarchy level only) 
by specifying an appropriate number of blocks. The method used is a generalization of 
the one implemented in function <code><a href="../../conf.design/html/conf.design.html">conf.design</a></code> for 
symmetric factorials (i.e. factorials with all factors at the same prime number 
of levels) and related to the method described in Collings (1984, 1989); 
function <code><a href="../../conf.design/html/conf.set.html">conf.set</a></code> from 
package <span class="pkg">conf.design</span> is used for checking the confounding 
consequences of blocking. 
</p>
<p>Note that the number of blocks must 
be compatible with the factor levels; it must factor into primes that occur with 
high enough frequency among the pseudo-factors of the design. 
This statement is now explained by an example: Consider a design with five factors at 
2, 2, 3, 3, 6 levels. The 6-level factor can be thought of as consisting of 
two pseudo-factors, a 2-level and a 3-level pseudo-factor, according to the 
factorization of the number 6 into the two primes 2 and 3. It is possible <br />
to obtain two blocks by confounding the two-factor interaction of the 
two 2-level factors and the 2-level pseudo-factor of the 6-level factor, <br />
or to obtain three blocks by confounding the blocking factor with the 
three-factor interaction of the two three-level factors and the three-level 
pseudo-factor of the 6-level factor, <br />
or to get six blocks, by doing both simultaneously. <br />
It is also possible to obtain 4 or 9 or even 36 blocks, if one is happy to 
confound two-factor interactions with blocks. The 36 blocks are the product 
of the 4 blocks from the 2-level portion with the nine blocks from the 3-level 
portion. For each portion separately, there is a lookup-table for blocking 
possibilities (<code><a href="block.catlg.html">block.catlg</a></code>), for up to 128 blocks in 256 runs, 
or up to 81 blocks in 243 runs. 
</p>
<p>5 blocks cannot be done for the above example design. Even if there were one additional 
factor at 5 levels, it would still not be possible to do a number of blocks 
with divisor 5, because this would confound the main effect of a factor with 
blocks and would thus generate an error. 
</p>
<p>For any primes apart from 2 or 3, only one at a time can be handled automatically. 
For example, if a design has three 5-level factors, it can be automatically subdivided 
into 5 blocks by the option <code>blocks=5</code>. 
It is also possible to run the design in 25 blocks; however, as 25=5*5, this cannot be done 
automatically but has to be requested by specifying the <code>block.gen</code> option
in addition to the <code>blocks</code> option 
(in this case, <code>block.gen=rbind(c(1,0,1),c(1,1,0))</code> would do the job).
</p>


<h3>Value</h3>

<p><code>fac.design</code> returns a data frame of S3 class <code><a href="class-design.html">design</a></code> 
with attributes attached. 
</p>
<p>The experimental factors are all stored as R factors. <br />
For factors with 2 levels, <code><a href="contr.FrF2.html">contr.FrF2</a></code> contrasts (-1 / +1) are used. <br />
For factors with more than 2 numerical levels, polynomial contrasts are used 
(i.e. analyses will per default use orthogonal polynomials). <br />
For factors with more than 2 categorical levels, the default contrasts are used.
</p>
<p>For changing the contrasts, use function <code><a href="qua.design.html">change.contr</a></code>.
</p>
<p>The <code>design.info</code> attribute of the data frame has the following elements:
</p>

<dl>
<dt>type</dt><dd><p> character string &ldquo;full factorial&rdquo; or 
&ldquo;full factorial.blocked&rdquo;</p>
</dd>
<dt>nruns</dt><dd><p> number of runs (replications are not counted) </p>
</dd>
<dt>nfactors</dt><dd><p> number of factors</p>
</dd>
<dt>nlevels</dt><dd><p> vector with number of levels for each factor </p>
</dd>
<dt>factor.names </dt><dd><p> list named with (treatment) factor names and containing as 
entries vectors with coded factor levels </p>
</dd>
<dt>nblocks</dt><dd><p>for designs of type <code>full factorial.blocked</code> only; <br />
number of blocks</p>
</dd>
<dt>block.gen</dt><dd><p>for designs of type <code>full factorial.blocked</code> only; <br />
matrix the rows of which are the coefficients of the linear combinations 
that create block columns from of pseudo factors</p>
</dd>
<dt>blocksize</dt><dd><p>for designs of type <code>full factorial.blocked</code> only; <br />
size of each block (without consideration of <code>wbreps</code>)</p>
</dd>
<dt>replication </dt><dd><p> option setting in call to <code>FrF2</code> </p>
</dd>
<dt>repeat.only </dt><dd><p> option setting in call to <code>FrF2</code> </p>
</dd>
<dt>bbreps</dt><dd><p>for designs of type <code>FrF2.blocked</code> only; 
number of between block replications</p>
</dd>
<dt>wbreps</dt><dd><p>for designs of type <code>FrF2.blocked</code> only; 
number of within block replications;<br />
<code>repeat.only</code> indicates whether these are replications or repetitions only</p>
</dd>
<dt>randomize </dt><dd><p> option setting in call to <code>FrF2</code> </p>
</dd>
<dt>seed </dt><dd><p> option setting in call to <code>FrF2</code> </p>
</dd>
<dt>creator </dt><dd><p> call to function FrF2 
(or stored menu settings, if the function has been called via the R commander plugin 
<span class="pkg">RcmdrPlugin.DoE</span>) </p>
</dd>
</dl>



<h3>Warning</h3>

<p>Since R version 3.6.0, the behavior of function <code><a href="../../base/html/sample.html">sample</a></code> has changed 
(correction of a biased previous behavior that should not be relevant for the randomization of designs). 
For reproducing a randomized design that was produced with an earlier R version, 
please follow the steps described with the argument <code>seed</code>.
</p>


<h3>Note</h3>

<p> This package is still under development. Suggestions and bug reports are welcome.</p>


<h3>Author(s)</h3>

<p> Ulrike Groemping </p>


<h3>References</h3>

 
<p>Collings, B.J. (1984). Generating the intrablock and interblock subgroups for 
confounding in general factorial experiments. <em>Annals of Statistics</em> <b>12</b>, 
1500&ndash;1509.
</p>
<p>Collings, B.J. (1989). Quick confounding. <em>Technometrics</em> <b>31</b>, 
107&ndash;110.
</p>


<h3>See Also</h3>

<p> See also <code><a href="../../FrF2/html/FrF2.html">FrF2</a></code>, <code><a href="oa.design.html">oa.design</a></code>, <code><a href="../../FrF2/html/pb.html">pb</a></code>, <code><a href="../../conf.design/html/conf.set.html">conf.set</a></code>, 
<code><a href="block.catlg.html">block.catlg</a></code></p>


<h3>Examples</h3>

<pre>
  ## only specify level combination 
  fac.design(nlevels=c(4,3,3,2))
  ## design requested via factor.names
  fac.design(factor.names=list(one=c("a","b","c"), two=c(125,275), 
     three=c("old","new"), four=c(-1,1), five=c("min","medium","max")))
  ## design requested via character factor.names and nlevels 
  ##    (with a little German lesson for one two three)
  fac.design(factor.names=c("eins","zwei","drei"),nlevels=c(2,3,2))
  
  ### blocking designs
  fac.design(nlevels=c(2,2,3,3,6), blocks=6, seed=12345)
  ## the same design, now unnecessarily constructed via option block.gen
  ## preparation: look at the numbers of levels of pseudo factors
  ## (in this order)
  unlist(factorize(c(2,2,3,3,6)))
  ## or, for more annotation, factorize the unblocked design
  factorize(fac.design(nlevels=c(2,2,3,3,6)))
  ## positions 1 2 5 are 2-level pseudo factors
  ## positions 3 4 6 are 4-level pseudo factors
  ## blocking with highest possible interactions
  G &lt;- rbind(two=c(1,1,0,0,1,0),three=c(0,0,1,1,0,1))
  plan.6blocks &lt;- fac.design(nlevels=c(2,2,3,3,6), blocks=6, block.gen=G, seed=12345)
  plan.6blocks
  
  ## two blocks, default design, but unnecessarily constructed via block.gen
  fac.design(nlevels=c(2,2,3,3,6), blocks=2, block.gen=c(1,1,0,0,1,0), seed=12345)
  
  ## three blocks, default design, but unnecessarily constructed via block.gen
  fac.design(nlevels=c(2,2,3,3,6), blocks=3, block.gen=c(0,0,1,1,0,1), seed=12345)
  
  ## nine blocks
  ## confounding two-factor interactions cannot be avoided
  ## there are warnings to that effect
  G &lt;- rbind(CD=c(0,0,1,1,0,0),CE2=c(0,0,1,0,0,1))
  plan.9blocks &lt;- fac.design(nlevels=c(2,2,3,3,6), blocks=9, block.gen=G, seed=12345)

  ## further automatic designs, not run for shortening run time 
  ## Not run: 
  fac.design(nlevels=c(2,2,3,3,6), blocks=4, seed=12345)
  fac.design(nlevels=c(2,2,3,3,6), blocks=9, seed=12345)
  fac.design(nlevels=c(2,2,3,3,6), blocks=36, seed=12345)
  fac.design(nlevels=c(3,5,6,10), blocks=15, seed=12345)
  
## End(Not run)
   
  ## independently check aliasing
  ## model with block main effects and all two-factor interactions
  ## 6 factors: not aliased
  summary(plan.6blocks)
  alias(lm(1:nrow(plan.6blocks)~Blocks+(A+B+C+D+E)^2,plan.6blocks))
  ## 9 factors: aliased
  summary(plan.9blocks)
  alias(lm(1:nrow(plan.9blocks)~Blocks+(A+B+C+D+E)^2,plan.9blocks))
</pre>

<hr /><div style="text-align: center;">[Package <em>DoE.base</em> version 1.1-4 <a href="00Index.html">Index</a>]</div>
</body></html>

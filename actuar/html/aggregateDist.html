<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Aggregate Claim Amount Distribution</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for aggregateDist {actuar}"><tr><td>aggregateDist {actuar}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Aggregate Claim Amount Distribution</h2>

<h3>Description</h3>

<p>Compute the aggregate claim amount cumulative distribution function of
a portfolio over a period using one of five methods.
</p>


<h3>Usage</h3>

<pre>
aggregateDist(method = c("recursive", "convolution", "normal",
                         "npower", "simulation"),
              model.freq = NULL, model.sev = NULL, p0 = NULL,
              x.scale = 1, convolve = 0, moments, nb.simul, ...,
              tol = 1e-06, maxit = 500, echo = FALSE)

## S3 method for class 'aggregateDist'
print(x, ...)

## S3 method for class 'aggregateDist'
plot(x, xlim, ylab = expression(F[S](x)),
     main = "Aggregate Claim Amount Distribution",
     sub = comment(x), ...)

## S3 method for class 'aggregateDist'
summary(object, ...)

## S3 method for class 'aggregateDist'
mean(x, ...)

## S3 method for class 'aggregateDist'
diff(x, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>method</code></td>
<td>
<p>method to be used</p>
</td></tr>
<tr valign="top"><td><code>model.freq</code></td>
<td>
<p>for <code>"recursive"</code> method: a character string
giving the name of a distribution in the <i>(a, b, 0)</i> or <i>(a,
      b, 1)</i> families of distributions. For <code>"convolution"</code> method:
a vector of claim number probabilities. For <code>"simulation"</code>
method: a frequency simulation model (see <code><a href="simul.html">simul</a></code> for
details) or <code>NULL</code>. Ignored with <code>normal</code> and
<code>npower</code> methods.</p>
</td></tr>
<tr valign="top"><td><code>model.sev</code></td>
<td>
<p>for <code>"recursive"</code> and <code>"convolution"</code>
methods: a vector of claim amount probabilities. For
<code>"simulation"</code> method: a severity simulation model (see
<code><a href="simul.html">simul</a></code> for details) or <code>NULL</code>. Ignored with
<code>normal</code> and <code>npower</code> methods.</p>
</td></tr>
<tr valign="top"><td><code>p0</code></td>
<td>
<p>arbitrary probability at zero for the frequency
distribution. Creates a zero-modified or zero-truncated
distribution if not <code>NULL</code>. Used only with <code>"recursive"</code>
method.</p>
</td></tr>
<tr valign="top"><td><code>x.scale</code></td>
<td>
<p>value of an amount of 1 in the severity model (monetary
unit). Used only with <code>"recursive"</code> and <code>"convolution"</code>
methods.</p>
</td></tr>
<tr valign="top"><td><code>convolve</code></td>
<td>
<p>number of times to convolve the resulting distribution
with itself. Used only with <code>"recursive"</code> method.</p>
</td></tr>
<tr valign="top"><td><code>moments</code></td>
<td>
<p>vector of the true moments of the aggregate claim
amount distribution; required only by the <code>"normal"</code> or
<code>"npower"</code> methods.</p>
</td></tr>
<tr valign="top"><td><code>nb.simul</code></td>
<td>
<p>number of simulations for the <code>"simulation"</code> method.</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>parameters of the frequency distribution for the
<code>"recursive"</code> method; further arguments to be passed to or
from other methods otherwise.</p>
</td></tr>
<tr valign="top"><td><code>tol</code></td>
<td>
<p>the resulting cumulative distribution in the
<code>"recursive"</code> method will get less than <code>tol</code> away from
1.</p>
</td></tr>
<tr valign="top"><td><code>maxit</code></td>
<td>
<p>maximum number of recursions in the <code>"recursive"</code>
method.</p>
</td></tr>
<tr valign="top"><td><code>echo</code></td>
<td>
<p>logical; echo the recursions to screen in the
<code>"recursive"</code> method.</p>
</td></tr>
<tr valign="top"><td><code>x, object</code></td>
<td>
<p>an object of class <code>"aggregateDist"</code>.</p>
</td></tr>
<tr valign="top"><td><code>xlim</code></td>
<td>
<p>numeric of length 2; the <i>x</i> limits of the plot.</p>
</td></tr>
<tr valign="top"><td><code>ylab</code></td>
<td>
<p>label of the y axis.</p>
</td></tr>
<tr valign="top"><td><code>main</code></td>
<td>
<p>main title.</p>
</td></tr>
<tr valign="top"><td><code>sub</code></td>
<td>
<p>subtitle, defaulting to the calculation method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>aggregateDist</code> returns a function to compute the cumulative
distribution function (cdf) of the aggregate claim amount distribution
in any point.
</p>
<p>The <code>"recursive"</code> method computes the cdf using the Panjer
algorithm; the <code>"convolution"</code> method using convolutions; the
<code>"normal"</code> method using a normal approximation; the
<code>"npower"</code> method using the Normal Power 2 approximation; the
<code>"simulation"</code> method using simulations. More details follow.
</p>


<h3>Value</h3>

<p>A function of class <code>"aggregateDist"</code>, inheriting from the
<code>"function"</code> class when using normal and Normal Power
approximations and additionally inheriting from the <code>"ecdf"</code> and
<code>"stepfun"</code> classes when other methods are used.
</p>
<p>There are methods available to summarize (<code>summary</code>), represent
(<code>print</code>), plot (<code>plot</code>), compute quantiles
(<code>quantile</code>) and compute the mean (<code>mean</code>) of
<code>"aggregateDist"</code> objects.
</p>
<p>For the <code>diff</code> method: a numeric vector of probabilities
corresponding to the probability mass function evaluated
at the knots of the distribution.
</p>


<h3>Recursive method</h3>

<p>The frequency distribution must be a member of the <i>(a, b, 0)</i> or
<i>(a, b, 1)</i> families of discrete distributions.
</p>
<p>To use a distribution from the <i>(a, b, 0)</i> family,
<code>model.freq</code> must be one of
<code>"binomial"</code>,
<code>"geometric"</code>,
<code>"negative binomial"</code> or
<code>"poisson"</code>,
and <code>p0</code> must be <code>NULL</code>.
</p>
<p>To use a zero-truncated distribution from the <i>(a, b, 1)</i> family,
<code>model.freq</code> may be one of the strings above together with
<code>p0 = 0</code>. As a shortcut, <code>model.freq</code> may also be one of
<code>"zero-truncated binomial"</code>,
<code>"zero-truncated geometric"</code>,
<code>"zero-truncated negative binomial"</code>,
<code>"zero-truncated poisson"</code> or
<code>"logarithmic"</code>,
and <code>p0</code> is then ignored (with a warning if non <code>NULL</code>).
</p>
<p>(Note: since the logarithmic distribution is always zero-truncated.
<code>model.freq = "logarithmic"</code> may be used with either <code>p0 =
  NULL</code> or <code>p0 = 0</code>.)
</p>
<p>To use a zero-modified distribution from the <i>(a, b, 1)</i> family,
<code>model.freq</code> may be one of standard frequency distributions
mentioned above with <code>p0</code> set to some probability that the
distribution takes the value <i>0</i>. It is equivalent, but more
explicit, to set <code>model.freq</code> to one of
<code>"zero-modified binomial"</code>,
<code>"zero-modified geometric"</code>,
<code>"zero-modified negative binomial"</code>,
<code>"zero-modified poisson"</code> or
<code>"zero-modified logarithmic"</code>.
</p>
<p>The parameters of the frequency distribution must be specified using
names identical to the arguments of the appropriate function
<code><a href="../../stats/html/Binomial.html">dbinom</a></code>, <code><a href="../../stats/html/Geometric.html">dgeom</a></code>, <code><a href="../../stats/html/NegBinomial.html">dnbinom</a></code>,
<code><a href="../../stats/html/Poisson.html">dpois</a></code> or <code><a href="Logarithmic.html">dlogarithmic</a></code>. In the latter case,
do take note that the parametrization of <code>dlogarithmic</code> is
different from Appendix B of Klugman et al. (2012).
</p>
<p>If the length of <code>p0</code> is greater than one, only the first element
is used, with a warning.
</p>
<p><code>model.sev</code> is a vector of the (discretized) claim amount
distribution <i>X</i>; the first element <strong>must</strong> be <i>fx(0) = Pr[X = 0]</i>.
</p>
<p>The recursion will fail to start if the expected number of claims is
too large. One may divide the appropriate parameter of the frequency
distribution by <i>2^n</i> and convolve the resulting distribution
<i>n =</i> <code>convolve</code> times.
</p>
<p>Failure to obtain a cumulative distribution function less than
<code>tol</code> away from 1 within <code>maxit</code> iterations is often due
to too coarse a discretization of the severity distribution.
</p>


<h3>Convolution method</h3>

<p>The cumulative distribution function (cdf) <i>Fs(x)</i> of the
aggregate claim amount of a portfolio in the collective risk model is
</p>
<p style="text-align: center;"><i>
    Fs(x) = sum(n; Fx^{*n}(x) * pn)</i></p>

<p>for <i>x = 0, 1, &hellip;</i>; <i>pn = Pr[N = n]</i> is
the frequency probability mass function and
<i>Fx^{*n}(x)</i> is the cdf of the <i>n</i>th convolution of
the (discrete) claim amount random variable.
</p>
<p><code>model.freq</code> is vector <i>pn</i> of the number of claims
probabilities; the first element <strong>must</strong> be <i>Pr[N = 0]</i>.
</p>
<p><code>model.sev</code> is vector <i>fx(x)</i> of the (discretized)
claim amount distribution; the first element <strong>must</strong> be
<i>fx(0)</i>.
</p>


<h3>Normal and Normal Power 2 methods</h3>

<p>The Normal approximation of a cumulative distribution function (cdf)
<i>F(x)</i> with mean <i>m</i> and standard deviation
<i>s</i> is
</p>
<p style="text-align: center;"><i>
    F(x) ~= pnorm((x - m)/s).</i></p>

<p>The Normal Power 2 approximation of a cumulative distribution function (cdf)
<i>F(x)</i> with mean <i>m</i>, standard deviation <i>s</i>
and skewness <i>g</i> is
</p>
<p style="text-align: center;"><i>
    F(x) ~= pnorm(-3/g + sqrt(9/g^2 + 1 + (6/g) * (x - m)/s)).</i></p>

<p>This formula is valid only for the right-hand tail of the distribution
and skewness should not exceed unity.
</p>


<h3>Simulation method</h3>

<p>This methods returns the empirical distribution function of a sample
of size <code>nb.simul</code> of the aggregate claim amount distribution
specified by <code>model.freq</code> and
<code>model.sev</code>. <code><a href="simul.html">simul</a></code> is used for the simulation of
claim amounts, hence both the frequency and severity models can be
mixtures of distributions.
</p>


<h3>Author(s)</h3>

<p>Vincent Goulet <a href="mailto:vincent.goulet@act.ulaval.ca">vincent.goulet@act.ulaval.ca</a> and
Louis-Philippe Pouliot
</p>


<h3>References</h3>

<p>Klugman, S. A., Panjer, H. H. and Willmot, G. E. (2012),
<em>Loss Models, From Data to Decisions, Fourth Edition</em>, Wiley.
</p>
<p>Daykin, C.D., Pentikäinen, T. and Pesonen, M.
(1994), <em>Practical Risk Theory for Actuaries</em>, Chapman &amp; Hall.
</p>


<h3>See Also</h3>

<p><code><a href="discretize.html">discretize</a></code> to discretize a severity distribution;
<code><a href="aggregateDist.html">mean.aggregateDist</a></code> to compute the mean of the
distribution;
<code><a href="quantile.aggregateDist.html">quantile.aggregateDist</a></code> to compute the quantiles or the
Value-at-Risk;
<code><a href="CTE.html">CTE.aggregateDist</a></code> to compute the Conditional Tail
Expectation (or Tail Value-at-Risk);
<code><a href="simul.html">simul</a></code>.
</p>


<h3>Examples</h3>

<pre>
## Convolution method (example 9.5 of Klugman et al. (2012))
fx &lt;- c(0, 0.15, 0.2, 0.25, 0.125, 0.075,
        0.05, 0.05, 0.05, 0.025, 0.025)
pn &lt;- c(0.05, 0.1, 0.15, 0.2, 0.25, 0.15, 0.06, 0.03, 0.01)
Fs &lt;- aggregateDist("convolution", model.freq = pn,
                    model.sev = fx, x.scale = 25)
summary(Fs)
c(Fs(0), diff(Fs(25 * 0:21))) # probability mass function
plot(Fs)

## Recursive method (example 9.10 of Klugman et al. (2012))
fx &lt;- c(0, crossprod(c(2, 1)/3,
                     matrix(c(0.6, 0.7, 0.4, 0, 0, 0.3), 2, 3)))
Fs &lt;- aggregateDist("recursive", model.freq = "poisson",
                    model.sev = fx, lambda = 3)
plot(Fs)
Fs(knots(Fs))		      # cdf evaluated at its knots
diff(Fs)                      # probability mass function

## Recursive method (high frequency)
fx &lt;- c(0, 0.15, 0.2, 0.25, 0.125, 0.075,
        0.05, 0.05, 0.05, 0.025, 0.025)
## Not run: Fs &lt;- aggregateDist("recursive", model.freq = "poisson",
                    model.sev = fx, lambda = 1000)
## End(Not run)
Fs &lt;- aggregateDist("recursive", model.freq = "poisson",
                    model.sev = fx, lambda = 250, convolve = 2, maxit = 1500)
plot(Fs)

## Recursive method (zero-modified distribution; example 9.11 of
## Klugman et al. (2012))
Fn &lt;- aggregateDist("recursive", model.freq = "binomial",
                    model.sev = c(0.3, 0.5, 0.2), x.scale = 50,
                    p0 = 0.4, size = 3, prob = 0.3)
diff(Fn)

## Equivalent but more explicit call
aggregateDist("recursive", model.freq = "zero-modified binomial",
              model.sev = c(0.3, 0.5, 0.2), x.scale = 50,
              p0 = 0.4, size = 3, prob = 0.3)

## Recursive method (zero-truncated distribution). Using 'fx' above
## would mean that both Pr[N = 0] = 0 and Pr[X = 0] = 0, therefore
## Pr[S = 0] = 0 and recursions would not start.
fx &lt;- discretize(pexp(x, 1), from = 0, to = 100, method = "upper")
fx[1L] # non zero
aggregateDist("recursive", model.freq = "zero-truncated poisson",
              model.sev = fx, lambda = 3, x.scale = 25, echo=TRUE)

## Normal Power approximation
Fs &lt;- aggregateDist("npower", moments = c(200, 200, 0.5))
Fs(210)

## Simulation method
model.freq &lt;- expression(data = rpois(3))
model.sev &lt;- expression(data = rgamma(100, 2))
Fs &lt;- aggregateDist("simulation", nb.simul = 1000,
                    model.freq, model.sev)
mean(Fs)
plot(Fs)

## Evaluation of ruin probabilities using Beekman's formula with
## Exponential(1) claim severity, Poisson(1) frequency and premium rate
## c = 1.2.
fx &lt;- discretize(pexp(x, 1), from = 0, to = 100, method = "lower")
phi0 &lt;- 0.2/1.2
Fs &lt;- aggregateDist(method = "recursive", model.freq = "geometric",
                    model.sev = fx, prob = phi0)
1 - Fs(400)			# approximate ruin probability
u &lt;- 0:100
plot(u, 1 - Fs(u), type = "l", main = "Ruin probability")
</pre>

<hr /><div style="text-align: center;">[Package <em>actuar</em> version 2.2-0 <a href="00Index.html">Index</a>]</div>
</body></html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Data Splitting functions</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for createDataPartition {caret}"><tr><td>createDataPartition {caret}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Data Splitting functions</h2>

<h3>Description</h3>

<p>A series of test/training partitions are created using
<code>createDataPartition</code> while <code>createResample</code> creates one or more
bootstrap samples. <code>createFolds</code> splits the data into <code>k</code> groups
while <code>createTimeSlices</code> creates cross-validation split for series data.
<code>groupKFold</code> splits the data based on a grouping factor.
</p>


<h3>Usage</h3>

<pre>
createDataPartition(y, times = 1, p = 0.5, list = TRUE, groups = min(5,
  length(y)))

createFolds(y, k = 10, list = TRUE, returnTrain = FALSE)

createTimeSlices(y, initialWindow, horizon = 1, fixedWindow = TRUE,
  skip = 0)

groupKFold(group, k = length(unique(group)))

createResample(y, times = 10, list = TRUE)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>y</code></td>
<td>
<p>a vector of outcomes. For <code>createTimeSlices</code>, these should be
in chronological order.</p>
</td></tr>
<tr valign="top"><td><code>times</code></td>
<td>
<p>the number of partitions to create</p>
</td></tr>
<tr valign="top"><td><code>p</code></td>
<td>
<p>the percentage of data that goes to training</p>
</td></tr>
<tr valign="top"><td><code>list</code></td>
<td>
<p>logical - should the results be in a list (<code>TRUE</code>) or a
matrix with the number of rows equal to <code>floor(p * length(y))</code> and
<code>times</code> columns.</p>
</td></tr>
<tr valign="top"><td><code>groups</code></td>
<td>
<p>for numeric <code>y</code>, the number of breaks in the quantiles
(see below)</p>
</td></tr>
<tr valign="top"><td><code>k</code></td>
<td>
<p>an integer for the number of folds.</p>
</td></tr>
<tr valign="top"><td><code>returnTrain</code></td>
<td>
<p>a logical. When true, the values returned are the sample
positions corresponding to the data used during training. This argument
only works in conjunction with <code>list = TRUE</code></p>
</td></tr>
<tr valign="top"><td><code>initialWindow</code></td>
<td>
<p>The initial number of consecutive values in each
training set sample</p>
</td></tr>
<tr valign="top"><td><code>horizon</code></td>
<td>
<p>the number of consecutive values in test set sample</p>
</td></tr>
<tr valign="top"><td><code>fixedWindow</code></td>
<td>
<p>logical, if <code>FALSE</code>, all training samples start at 1</p>
</td></tr>
<tr valign="top"><td><code>skip</code></td>
<td>
<p>integer, how many (if any) resamples to skip to thin the total
amount</p>
</td></tr>
<tr valign="top"><td><code>group</code></td>
<td>
<p>a vector of groups whose length matches the number of rows in 
the overall data set.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For bootstrap samples, simple random sampling is used.
</p>
<p>For other data splitting, the random sampling is done within the levels of
<code>y</code> when <code>y</code> is a factor in an attempt to balance the class
distributions within the splits.
</p>
<p>For numeric <code>y</code>, the sample is split into groups sections based on
percentiles and sampling is done within these subgroups. For
<code>createDataPartition</code>, the number of percentiles is set via the
<code>groups</code> argument. For <code>createFolds</code> and <code>createMultiFolds</code>,
the number of groups is set dynamically based on the sample size and
<code>k</code>.  For smaller samples sizes, these two functions may not do
stratified splitting and, at most, will split the data into quartiles.
</p>
<p>Also, for <code>createDataPartition</code>, very small class sizes (&lt;= 3) the
classes may not show up in both the training and test data
</p>
<p>For multiple k-fold cross-validation, completely independent folds are
created.  The names of the list objects will denote the fold membership
using the pattern &quot;Foldi.Repj&quot; meaning the ith section (of k) of the jth
cross-validation set (of <code>times</code>). Note that this function calls
<code>createFolds</code> with <code>list = TRUE</code> and <code>returnTrain = TRUE</code>.
</p>
<p>Hyndman and Athanasopoulos (2013)) discuss rolling forecasting origin
techniques that move the training and test sets in time.
<code>createTimeSlices</code> can create the indices for this type of splitting.
</p>
<p>For Group k-fold cross-validation, the data are split such that no group
is contained in both the modeling and holdout sets. One or more group 
could be left out, depending on the value of <code>k</code>.
</p>


<h3>Value</h3>

<p>A list or matrix of row position integers corresponding to the
training data. For <code>createTimeSlices</code> subsamples are named by the end
index of each training subsample.
</p>


<h3>Author(s)</h3>

<p>Max Kuhn, <code>createTimeSlices</code> by Tony Cooper
</p>


<h3>References</h3>

<p><a href="http://topepo.github.io/caret/data-splitting.html">http://topepo.github.io/caret/data-splitting.html</a>
</p>
<p>Hyndman and Athanasopoulos (2013), Forecasting: principles and practice.
<a href="https://www.otexts.org/fpp">https://www.otexts.org/fpp</a>
</p>


<h3>Examples</h3>

<pre>

data(oil)
createDataPartition(oilType, 2)

x &lt;- rgamma(50, 3, .5)
inA &lt;- createDataPartition(x, list = FALSE)

plot(density(x[inA]))
rug(x[inA])

points(density(x[-inA]), type = "l", col = 4)
rug(x[-inA], col = 4)

createResample(oilType, 2)

createFolds(oilType, 10)
createFolds(oilType, 5, FALSE)

createFolds(rnorm(21))

createTimeSlices(1:9, 5, 1, fixedWindow = FALSE)
createTimeSlices(1:9, 5, 1, fixedWindow = TRUE)
createTimeSlices(1:9, 5, 3, fixedWindow = TRUE)
createTimeSlices(1:9, 5, 3, fixedWindow = FALSE)

createTimeSlices(1:15, 5, 3)
createTimeSlices(1:15, 5, 3, skip = 2)
createTimeSlices(1:15, 5, 3, skip = 3)

set.seed(131)
groups &lt;- sort(sample(letters[1:4], size = 20, replace = TRUE))
table(groups)
folds &lt;- groupKFold(groups)
lapply(folds, function(x, y) table(y[x]), y = groups)
</pre>

<hr /><div style="text-align: center;">[Package <em>caret</em> version 6.0-79 <a href="00Index.html">Index</a>]</div>
</body></html>

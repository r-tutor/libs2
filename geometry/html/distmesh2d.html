<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: A simple mesh generator for non-convex regions</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for distmesh2d {geometry}"><tr><td>distmesh2d {geometry}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>A simple mesh generator for non-convex regions</h2>

<h3>Description</h3>

<p>An unstructured simplex requires a choice of mesh points (vertex nodes) and
a triangulation.  This is a simple and short algorithm that improves the
quality of a mesh by relocating the mesh points according to a relaxation
scheme of forces in a truss structure. The topology of the truss is reset
using Delaunay triangulation. A (sufficiently smooth) user supplied signed
distance function (<code>fd</code>) indicates if a given node is inside or
outside the region. Points outside the region are projected back to the
boundary.
</p>


<h3>Usage</h3>

<pre>
distmesh2d(fd, fh, h0, bbox, p = NULL, pfix = array(0, dim = c(0, 2)),
  ..., dptol = 0.001, ttol = 0.1, Fscale = 1.2, deltat = 0.2,
  geps = 0.001 * h0, deps = sqrt(.Machine$double.eps) * h0,
  maxiter = 1000, plot = TRUE)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>fd</code></td>
<td>
<p>Vectorized signed distance function, for example
<code><a href="mesh.dcircle.html">mesh.dcircle</a></code> or <code><a href="mesh.diff.html">mesh.diff</a></code>, accepting
an <code>n</code>-by-<code>2</code> matrix, where <code>n</code> is arbitrary, as
the first argument.</p>
</td></tr>
<tr valign="top"><td><code>fh</code></td>
<td>
<p>Vectorized function, for example
<code><a href="mesh.hunif.html">mesh.hunif</a></code>, that returns desired edge length as a
function of position.  Accepts an <code>n</code>-by-<code>2</code> matrix,
where <code>n</code> is arbitrary, as its first argument.</p>
</td></tr>
<tr valign="top"><td><code>h0</code></td>
<td>
<p>Initial distance between mesh nodes. (Ignored of
<code>p</code> is supplied)</p>
</td></tr>
<tr valign="top"><td><code>bbox</code></td>
<td>
<p>Bounding box <code>cbind(c(xmin,xmax), c(ymin,ymax))</code></p>
</td></tr>
<tr valign="top"><td><code>p</code></td>
<td>
<p>An <code>n</code>-by-<code>2</code> matrix. The rows of <code>p</code>
represent locations of starting mesh nodes.</p>
</td></tr>
<tr valign="top"><td><code>pfix</code></td>
<td>
<p><code>nfix</code>-by-2 matrix with fixed node positions.</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>parameters to be passed to <code>fd</code> and/or <code>fh</code></p>
</td></tr>
<tr valign="top"><td><code>dptol</code></td>
<td>
<p>Algorithm stops when all node movements are smaller
than <code>dptol</code></p>
</td></tr>
<tr valign="top"><td><code>ttol</code></td>
<td>
<p>Controls how far the points can move (relatively)
before a retriangulation with <code><a href="delaunayn.html">delaunayn</a></code>.</p>
</td></tr>
<tr valign="top"><td><code>Fscale</code></td>
<td>
<p>&ldquo;Internal pressure&rdquo; in the edges.</p>
</td></tr>
<tr valign="top"><td><code>deltat</code></td>
<td>
<p>Size of the time step in Euler's method.</p>
</td></tr>
<tr valign="top"><td><code>geps</code></td>
<td>
<p>Tolerance in the geometry evaluations.</p>
</td></tr>
<tr valign="top"><td><code>deps</code></td>
<td>
<p>Stepsize <i>&Delta; x</i> in numerical derivative
computation for distance function.</p>
</td></tr>
<tr valign="top"><td><code>maxiter</code></td>
<td>
<p>Maximum iterations.</p>
</td></tr>
<tr valign="top"><td><code>plot</code></td>
<td>
<p>logical.  If <code>TRUE</code> (default), the mesh is
plotted as it is generated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an implementation of original Matlab software of Per-Olof Persson.
</p>
<p>Excerpt (modified) from the reference below:
</p>
<p>&lsquo;The algorithm is based on a mechanical analogy between a triangular
mesh and a 2D truss structure. In the physical model, the edges of the
Delaunay triangles of a set of points correspond to bars of a truss. Each
bar has a force-displacement relationship <i>F(L,L0)</i>
depending on its current length <i>L</i> and its unextended length
<i>L0</i>.&rsquo;
</p>
<p>&lsquo;External forces on the structure come at the boundaries, on which
external forces have normal orientations. These external forces are just
large enough to prevent nodes from moving outside the boundary. The
position of the nodes are the unknowns, and are found by solving for a
static force equilibrium. The hope is that (when <code>fh = function(p)
return(rep(1,nrow(p)))</code>), the lengths of all the bars at equilibrium will
be nearly equal, giving a well-shaped triangular mesh.&rsquo;
</p>
<p>See the references below for all details. Also, see the comments in the
source file.
</p>


<h3>Value</h3>

<p><code>n</code>-by-<code>2</code> matrix with node positions.
</p>


<h3>Wishlist </h3>

 <ul>
<li><p> Implement in C/Fortran
</p>
</li>
<li><p> Implement an <code>n</code>D version as provided in the Matlab
package </p>
</li>
<li><p> Translate other functions of the Matlab package </p>
</li></ul>



<h3>Author(s)</h3>

<p>Raoul Grasman
</p>


<h3>References</h3>

<p><a href="http://persson.berkeley.edu/distmesh/">http://persson.berkeley.edu/distmesh/</a>
</p>
<p><cite>P.-O. Persson, G. Strang, A Simple Mesh Generator in MATLAB. SIAM
Review, Volume 46 (2), pp. 329-345, June 2004</cite>
</p>


<h3>See Also</h3>

<p><code><a href="../../tripack/html/tri.mesh.html">tri.mesh</a></code>, <code><a href="delaunayn.html">delaunayn</a></code>,
<code><a href="mesh.dcircle.html">mesh.dcircle</a></code>, <code><a href="mesh.drectangle.html">mesh.drectangle</a></code>,
<code><a href="mesh.diff.html">mesh.diff</a></code>, <code><a href="mesh.diff.html">mesh.union</a></code>,
<code><a href="mesh.diff.html">mesh.intersect</a></code>
</p>


<h3>Examples</h3>

<pre>

# examples distmesh2d
fd &lt;- function(p, ...) sqrt((p^2)%*%c(1,1)) - 1
     # also predefined as `mesh.dcircle'
fh &lt;- function(p,...)  rep(1,nrow(p))
bbox &lt;- matrix(c(-1,1,-1,1),2,2)
p &lt;- distmesh2d(fd,fh,0.2,bbox, maxiter=100)
    # this may take a while:
    # press Esc to get result of current iteration

# example with non-convex region
fd &lt;- function(p, ...) mesh.diff(p , mesh.drectangle, mesh.dcircle, radius=.3)
     # fd defines difference of square and circle

p &lt;- distmesh2d(fd,fh,0.05,bbox,radius=0.3,maxiter=4)
p &lt;- distmesh2d(fd,fh,0.05,bbox,radius=0.3, maxiter=10)
     # continue on previous mesh
</pre>

<hr /><div style="text-align: center;">[Package <em>geometry</em> version 0.4.1.1 <a href="00Index.html">Index</a>]</div>
</body></html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: A simple mesh generator for non-convex regions in n-D space</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for distmeshnd {geometry}"><tr><td>distmeshnd {geometry}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>A simple mesh generator for non-convex regions in n-D space</h2>

<h3>Description</h3>

<p>An unstructured simplex requires a choice of mesh points (vertex nodes) and
a triangulation.  This is a simple and short algorithm that improves the
quality of a mesh by relocating the mesh points according to a relaxation
scheme of forces in a truss structure. The topology of the truss is reset
using Delaunay triangulation. A (sufficiently smooth) user supplied signed
distance function (<code>fd</code>) indicates if a given node is inside or
outside the region. Points outside the region are projected back to the
boundary.
</p>


<h3>Usage</h3>

<pre>
distmeshnd(fdist, fh, h, box, pfix = array(dim = c(0, ncol(box))), ...,
  ptol = 0.001, ttol = 0.1, deltat = 0.1, geps = 0.1 * h,
  deps = sqrt(.Machine$double.eps) * h)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>fdist</code></td>
<td>
<p>Vectorized signed distance function, for example
<code><a href="mesh.dsphere.html">mesh.dsphere</a></code>, accepting an <code>m</code>-by-<code>n</code>
matrix, where <code>m</code> is arbitrary, as the first argument.</p>
</td></tr>
<tr valign="top"><td><code>fh</code></td>
<td>
<p>Vectorized function, for example <code><a href="mesh.hunif.html">mesh.hunif</a></code>,
that returns desired edge length as a function of position.
Accepts an <code>m</code>-by-<code>n</code> matrix, where <code>n</code> is
arbitrary, as its first argument.</p>
</td></tr>
<tr valign="top"><td><code>h</code></td>
<td>
<p>Initial distance between mesh nodes.</p>
</td></tr>
<tr valign="top"><td><code>box</code></td>
<td>
<p><code>2</code>-by-<code>n</code> matrix that specifies the bounding box.
(See <a href="distmesh2d.html">distmesh2d</a> for an example.)</p>
</td></tr>
<tr valign="top"><td><code>pfix</code></td>
<td>
<p><code>nfix</code>-by-2 matrix with fixed node positions.</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>parameters that are passed to <code>fdist</code> and <code>fh</code></p>
</td></tr>
<tr valign="top"><td><code>ptol</code></td>
<td>
<p>Algorithm stops when all node movements are smaller than
<code>dptol</code></p>
</td></tr>
<tr valign="top"><td><code>ttol</code></td>
<td>
<p>Controls how far the points can move (relatively) before a
retriangulation with <code><a href="delaunayn.html">delaunayn</a></code>.</p>
</td></tr>
<tr valign="top"><td><code>deltat</code></td>
<td>
<p>Size of the time step in Euler's method.</p>
</td></tr>
<tr valign="top"><td><code>geps</code></td>
<td>
<p>Tolerance in the geometry evaluations.</p>
</td></tr>
<tr valign="top"><td><code>deps</code></td>
<td>
<p>Stepsize <i>&Delta; x</i> in numerical derivative computation for
distance function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an implementation of original Matlab software of Per-Olof Persson.
</p>
<p>Excerpt (modified) from the reference below:
</p>
<p>&lsquo;The algorithm is based on a mechanical analogy between a triangular
mesh and a n-D truss structure. In the physical model, the edges of the
Delaunay triangles of a set of points correspond to bars of a truss. Each
bar has a force-displacement relationship <i>F(L,L0)</i>
depending on its current length <i>L</i> and its unextended length
<i>L0</i>.&rsquo;
</p>
<p>&lsquo;External forces on the structure come at the boundaries, on which
external forces have normal orientations. These external forces are just
large enough to prevent nodes from moving outside the boundary. The
position of the nodes are the unknowns, and are found by solving for a
static force equilibrium. The hope is that (when <code>fh = function(p)
return(rep(1,nrow(p)))</code>), the lengths of all the bars at equilibrium will
be nearly equal, giving a well-shaped triangular mesh.&rsquo;
</p>
<p>See the references below for all details. Also, see the comments in the
source file of <code>distmesh2d</code>.
</p>


<h3>Value</h3>

<p><code>m</code>-by-<code>n</code> matrix with node positions.
</p>


<h3>Wishlist </h3>

 <ul>
<li><p> Implement in C/Fortran </p>
</li>
<li><p> Translate
other functions of the Matlab package </p>
</li></ul>



<h3>Author(s)</h3>

<p>Raoul Grasman; translated from original Matlab sources of Per-Olof
Persson.
</p>


<h3>References</h3>

<p><a href="http://persson.berkeley.edu/distmesh/">http://persson.berkeley.edu/distmesh/</a>
</p>
<p><cite>P.-O. Persson, G. Strang, A Simple Mesh Generator in MATLAB. SIAM
Review, Volume 46 (2), pp. 329-345, June 2004</cite>
</p>


<h3>See Also</h3>

<p><code><a href="distmesh2d.html">distmesh2d</a></code>, <code><a href="../../tripack/html/tri.mesh.html">tri.mesh</a></code>,
<code><a href="delaunayn.html">delaunayn</a></code>, <code><a href="mesh.dsphere.html">mesh.dsphere</a></code>,
<code><a href="mesh.hunif.html">mesh.hunif</a></code>,<br /> <code><a href="mesh.diff.html">mesh.diff</a></code>,
<code><a href="mesh.diff.html">mesh.union</a></code>, <code><a href="mesh.diff.html">mesh.intersect</a></code>
</p>


<h3>Examples</h3>

<pre>

## Not run: 
# examples distmeshnd
require(rgl)

fd = function(p, ...) sqrt((p^2)%*%c(1,1,1)) - 1
     # also predefined as `mesh.dsphere'
fh = function(p,...)  rep(1,nrow(p))
     # also predefined as `mesh.hunif'
bbox = matrix(c(-1,1),2,3)
p = distmeshnd(fd,fh,0.2,bbox, maxiter=100)
    # this may take a while:
    # press Esc to get result of current iteration

## End(Not run)

</pre>

<hr /><div style="text-align: center;">[Package <em>geometry</em> version 0.4.5 <a href="00Index.html">Index</a>]</div>
</body></html>

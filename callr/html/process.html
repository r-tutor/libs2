<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: External process</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for process {callr}"><tr><td>process {callr}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>External process</h2>

<h3>Description</h3>

<p>Managing external processes from R is not trivial, and this
class aims to help with this deficiency. It is essentially a small
wrapper around the <code>system</code> base R function, to return the process
id of the started process, and set its standard output and error
streams. The process id is then used to manage the process.
</p>


<h3>Usage</h3>

<pre>p &lt;- process$new(command = NULL, args,
                 stdout = NULL, stderr = NULL, cleanup = TRUE,
                 echo_cmd = FALSE, supervise = FALSE,
                 windows_verbatim_args = FALSE,
                 windows_hide_window = FALSE,
                 encoding = "")

p$is_alive()
p$signal(signal)
p$kill(grace = 0.1)
p$wait(timeout = -1)
p$get_pid()
p$get_exit_status()
p$restart()
p$get_start_time()

p$read_output(n = -1)
p$read_error(n = -1)
p$read_output_lines(n = -1)
p$read_error_lines(n = -1)
p$get_output_connection()
p$get_error_connection()
p$is_incomplete_output()
p$is_incomplete_error()
p$read_all_output()
p$read_all_error()
p$read_all_output_lines()
p$read_all_error_lines()

p$poll_io(timeout)

print(p)
</pre>


<h3>Arguments</h3>


<ul>
<li> <p><code>p</code>: <code>process</code> object.
</p>
</li>
<li> <p><code>command</code>: Character scalar, the command to run.
Note that this argument is not passed to a shell, so no
tilde-expansion or variable substitution is performed on it.
It should not be quoted with <code><a href="../../base/html/shQuote.html">base::shQuote()</a></code>. See
<code><a href="../../base/html/normalizePath.html">base::normalizePath()</a></code> for tilde-expansion.
</p>
</li>
<li> <p><code>args</code>: Character vector, arguments to the command. They will be
used as is, without a shell. They don't need to be escaped.
</p>
</li>
<li> <p><code>stdout</code>: What to do with the standard output. Possible values:
<code>NULL</code>: discard it; a string, redirect it to this file;
<code>"|"</code>: create a connection for it.
</p>
</li>
<li> <p><code>stderr</code>: What to do with the standard error. Possible values:
<code>NULL</code>: discard it; a string, redirect it to this file;
<code>"|"</code>: create a connection for it.
</p>
</li>
<li> <p><code>cleanup</code>: Whether to kill the process (and its children)
if the <code>process</code> object is garbage collected.
</p>
</li>
<li> <p><code>echo_cmd</code>: Whether to print the command to the screen before
running it.
</p>
</li>
<li> <p><code>supervise</code>: Whether to register the process with a supervisor.
If <code>TRUE</code>, the supervisor will ensure that the process is
killed when the R process exits.
</p>
</li>
<li> <p><code>windows_verbatim_args</code>: Whether to omit quoting the arguments
on Windows. It is ignored on other platforms.
</p>
</li>
<li> <p><code>windows_hide_window</code>: Whether to hide the application's window
on Windows. It is ignored on other platforms.
</p>
</li>
<li> <p><code>signal</code>: An integer scalar, the id of the signal to send to
the process. See <code><a href="../../tools/html/pskill.html">tools::pskill()</a></code> for the list of signals.
</p>
</li>
<li> <p><code>grace</code>: Currently not used.
</p>
</li>
<li> <p><code>timeout</code>: Timeout in milliseconds, for the wait or the I/O
polling.
</p>
</li>
<li> <p><code>n</code>: Number of characters or lines to read.
</p>
</li>
<li> <p><code>encoding</code>: The encoding to assume for <code>stdout</code> and
<code>stderr</code>. By default the encoding of the current locale is
used. Note that <code>callr</code> always reencodes the output of
both streams in UTF-8 currently. If you want to read them
without any conversion, on all platforms, specify <code>"UTF-8"</code> as
encoding.
</p>
</li></ul>



<h3>Details</h3>

<p><code>$new()</code> starts a new process in the background, and then returns
immediately.
</p>
<p><code>$is_alive()</code> checks if the process is alive. Returns a logical
scalar.
</p>
<p><code>$signal()</code> sends a signal to the process. On Windows only the
<code>SIGINT</code>, <code>SIGTERM</code> and <code>SIGKILL</code> signals are interpreted,
and the special 0 signal, The first three all kill the process. The 0
signal return <code>TRUE</code> if the process is alive, and <code>FALSE</code>
otherwise. On Unix all signals are supported that the OS supports, and
the 0 signal as well.
</p>
<p><code>$kill()</code> kills the process. It also kills all of its child
processes, except if they have created a new process group (on Unix),
or job object (on Windows). It returns <code>TRUE</code> if the process
was killed, and <code>FALSE</code> if it was no killed (because it was
already finished/dead when <code>callr</code> tried to kill it).
</p>
<p><code>$wait()</code> waits until the process finishes, or a timeout happens.
Note that if the process never finishes, and the timeout is infinite
(the default), then R will never regain control. It returns
the process itself, invisibly.
</p>
<p><code>$get_pid()</code> returns the process id of the process.
</p>
<p><code>$get_exit_status</code> returns the exit code of the process if it has
finished and <code>NULL</code> otherwise.
</p>
<p><code>$restart()</code> restarts a process. It returns the process itself.
</p>
<p><code>$get_start_time()</code> returns the time when the process was
started.
</p>
<p><code>$is_supervised()</code> returns whether the process is being tracked by
supervisor process.
</p>
<p><code>$supervise()</code> if passed <code>TRUE</code>, tells the supervisor to start
tracking the process. If <code>FALSE</code>, tells the supervisor to stop
tracking the process. Note that even if the supervisor is disabled for a
process, if it was started with <code>cleanup=TRUE</code>, the process will
still be killed when the object is garbage collected.
</p>
<p><code>$read_output()</code> reads from the standard output connection of the
process. If the standard output connection was not requested, then
then it returns an error. It uses a non-blocking text connection. This
will work only if <code>stdout="|"</code> was used. Otherwise, it will throw an
error.
</p>
<p><code>$read_error()</code> is similar to <code>$read_output</code>, but it reads
from the standard error stream.
</p>
<p><code>$read_output_lines()</code> reads lines from standard output connection
of the process. If the standard output connection was not requested, then
then it returns an error. It uses a non-blocking text connection. This
will work only if <code>stdout="|"</code> was used. Otherwise, it will throw an
error.
</p>
<p><code>$read_error_lines()</code> is similar to <code>$read_output_lines</code>, but
it reads from the standard error stream.
</p>
<p><code>$has_output_connection()</code> returns <code>TRUE</code> if there is a connection
object for standard output; in other words, if <code>stdout="|"</code>. It returns
<code>FALSE</code> otherwise.
</p>
<p><code>$has_error_connection()</code> returns <code>TRUE</code> if there is a connection
object for standard error; in other words, if <code>stderr="|"</code>. It returns
<code>FALSE</code> otherwise.
</p>
<p><code>$get_output_connection()</code> returns a connection object, to the
standard output stream of the process.
</p>
<p><code>$get_error_conneciton()</code> returns a connection object, to the
standard error stream of the process.
</p>
<p><code>$is_incomplete_output()</code> return <code>FALSE</code> if the other end of
the standard output connection was closed (most probably because the
process exited). It return <code>TRUE</code> otherwise.
</p>
<p><code>$is_incomplete_error()</code> return <code>FALSE</code> if the other end of
the standard error connection was closed (most probably because the
process exited). It return <code>TRUE</code> otherwise.
</p>
<p><code>$read_all_output()</code> waits for all standard output from the process.
It does not return until the process has finished.
Note that this process involves waiting for the process to finish,
polling for I/O and potentically several <code>readLines()</code> calls.
It returns a character scalar. This will return content only if
<code>stdout="|"</code> was used. Otherwise, it will throw an error.
</p>
<p><code>$read_all_error()</code> waits for all standard error from the process.
It does not return until the process has finished.
Note that this process involves waiting for the process to finish,
polling for I/O and potentically several <code>readLines()</code> calls.
It returns a character scalar. This will return content only if
<code>stderr="|"</code> was used. Otherwise, it will throw an error.
</p>
<p><code>$read_all_output_lines()</code> waits for all standard output lines
from a process. It does not return until the process has finished.
Note that this process involves waiting for the process to finish,
polling for I/O and potentically several <code>readLines()</code> calls.
It returns a character vector. This will return content only if
<code>stdout="|"</code> was used. Otherwise, it will throw an error.
</p>
<p><code>$read_all_error_lines()</code> waits for all standard error lines from
a process. It does not return until the process has finished.
Note that this process involves waiting for the process to finish,
polling for I/O and potentically several <code>readLines()</code> calls.
It returns a character vector. This will return content only if
<code>stderr="|"</code> was used. Otherwise, it will throw an error.
</p>
<p><code>$get_output_file()</code> if the <code>stdout</code> argument was a filename,
this returns the absolute path to the file. If <code>stdout</code> was <code>"|"</code> or
<code>NULL</code>, this simply returns that value.
</p>
<p><code>$get_error_file()</code> if the <code>stderr</code> argument was a filename,
this returns the absolute path to the file. If <code>stderr</code> was <code>"|"</code> or
<code>NULL</code>, this simply returns that value.
</p>
<p><code>$poll_io()</code> polls the process's connections for I/O. See more in
the <em>Polling</em> section, and see also the <code><a href="poll.html">poll()</a></code> function
to poll on multiple processes.
</p>
<p><code>print(p)</code> or <code>p$print()</code> shows some information about the
process on the screen, whether it is running and it's process id, etc.
</p>


<h3>Polling</h3>

<p>The <code>poll_io()</code> function polls the standard output and standard
error connections of a process, with a timeout. If there is output
in either of them, or they are closed (e.g. because the process exits)
<code>poll_io()</code> returns immediately.
</p>
<p>In addition to polling a single process, the <code><a href="poll.html">poll()</a></code> function
can poll the output of several processes, and returns as soon as any
of them has generated output (or exited).
</p>


<h3>Examples</h3>

<pre>
# CRAN does not like long-running examples
## Not run: 
p &lt;- process$new("sleep", "2")
p$is_alive()
p
p$kill()
p$is_alive()

p$restart()
p$is_alive()
Sys.sleep(3)
p$is_alive()

## End(Not run)

</pre>

<hr /><div style="text-align: center;">[Package <em>callr</em> version 2.0.1 <a href="00Index.html">Index</a>]</div>
</body></html>

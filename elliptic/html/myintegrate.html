<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Complex integration</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for myintegrate {elliptic}"><tr><td>myintegrate {elliptic}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Complex integration</h2>

<h3>Description</h3>

<p>Integration of complex valued functions along the real axis
(<code>myintegrate()</code>), along arbitrary paths
(<code>integrate.contour()</code>), and following arbitrary straight line
segments (<code>integrate.segments()</code>).  Also, evaluation of a function at a
point using the residue theorem (<code>residue()</code>).
</p>


<h3>Usage</h3>

<pre>
myintegrate(f, lower,upper, ...)
integrate.contour(f,u,udash, ...)
integrate.segments(f,points, close=TRUE, ...)
residue(f, z0, r, O=z0, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>f</code></td>
<td>
<p>function, possibly complex valued</p>
</td></tr>
<tr valign="top"><td><code>lower,upper</code></td>
<td>
<p>Lower and upper limits of integration in <code>myintegrate()</code>; 
real numbers (for complex values, use <code>integrate.contour()</code> or
<code>integrate.segments()</code>)</p>
</td></tr>
<tr valign="top"><td><code>u</code></td>
<td>
<p>Function mapping <i>[0,1]</i> to the contour.  For a
closed contour, require that <i>u(0)=u(1)</i></p>
</td></tr>
<tr valign="top"><td><code>udash</code></td>
<td>
<p>Derivative of <code>u</code></p>
</td></tr>
<tr valign="top"><td><code>points</code></td>
<td>
<p>In function <code>integrate.segments()</code>, a vector of complex
numbers.  Integration will be taken over straight segments joining
consecutive elements of <code>points</code></p>
</td></tr>
<tr valign="top"><td><code>close</code></td>
<td>
<p>In function <code>integrate.segments()</code>, a Boolean
variable with default <code>TRUE</code> meaning to integrate along the segment
from <code>points[n]</code> to <code>points[1]</code> in addition to the internal
segments</p>
</td></tr>
<tr valign="top"><td><code>r,O,z0</code></td>
<td>
<p>In function <code>residue()</code> returns <code>f(z0)</code> by
integrating <i>f(z)/(z-z0)</i> around a circle of radius <code>r</code> and
center <code>O</code></p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>Extra arguments passed to <code>integrate()</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre>

f1 &lt;- function(z){sin(exp(z))}
f2 &lt;- function(z,p){p/z}

myintegrate(f1,2,3)  # that is, along the real axis


integrate.segments(f1,c(1,1i,-1,-1i),close=TRUE)   # should be zero

# (following should be pi*2i; note secondary argument):
integrate.segments(f2,points=c(1,1i,-1,-1i),close=TRUE,p=1)



# To integrate round the unit circle, we need the contour and its
# derivative:

 u &lt;- function(x){exp(pi*2i*x)}
 udash &lt;- function(x){pi*2i*exp(pi*2i*x)}

# Some elementary functions, for practice:

# (following should be 2i*pi; note secondary argument 'p'):
integrate.contour(function(z,p){p/z},u,udash,p=1)      
integrate.contour(function(z){log(z)},u,udash)         # should be -2i*pi
integrate.contour(function(z){sin(z)+1/z^2},u,udash)   # should be zero



# residue() is a convenience wrapper integrating f(z)/(z-z0) along a
# circular contour:

residue(function(z){1/z},2,r=0.1)  # should be 1/2=0.5



# Now, some elliptic functions:
g &lt;- c(3,2+4i)
Zeta &lt;- function(z){zeta(z,g)}
Sigma &lt;- function(z){sigma(z,g)}
WeierstrassP &lt;- function(z){P(z,g)}

jj &lt;- integrate.contour(Zeta,u,udash) 
abs(jj-2*pi*1i)                              # should be zero
abs(integrate.contour(Sigma,u,udash))        # should be zero
abs(integrate.contour(WeierstrassP,u,udash)) # should be zero




# Now integrate f(x) = exp(1i*x)/(1+x^2) from -Inf to +Inf along the
# real axis, using the Residue Theorem.  This tells us that integral of
# f(z) along any closed path is equal to pi*2i times the sum of the
# residues inside it.  Take a semicircular path P from -R to +R along
# the real axis, then following a semicircle in the upper half plane, of
# radius R to close the loop.  Now consider large R.  Then P encloses a
# pole at +1i [there is one at -1i also, but this is outside P, so
# irrelevent here] at which the residue is -1i/2e.  Thus the integral of
# f(z) = 2i*pi*(-1i/2e) = pi/e along P; the contribution from the
# semicircle tends to zero as R tends to infinity; thus the integral
# along the real axis is the whole path integral, or pi/e.

# We can now reproduce this result analytically.  First, choose an R:
R &lt;- 400

# now define P.  First, the semicircle, u1:
u1     &lt;- function(x){R*exp(pi*1i*x)}
u1dash &lt;- function(x){R*pi*1i*exp(pi*1i*x)}

# and now the straight part along the real axis, u2:
u2     &lt;- function(x){R*(2*x-1)}
u2dash &lt;- function(x){R*2}

# Better define the function:
f &lt;- function(z){exp(1i*z)/(1+z^2)}

# OK, now carry out the path integral.  I'll do it explicitly, but note
# that the contribution from the first integral should be small:

answer.approximate &lt;-
    integrate.contour(f,u1,u1dash) +
    integrate.contour(f,u2,u2dash) 

# And compare with the analytical value:
answer.exact &lt;- pi/exp(1)
abs(answer.approximate - answer.exact)


# Now try the same thing but integrating over a triangle, using
# integrate.segments().  Use a path P' with base from -R to +R along the
# real axis, closed by two straight segments, one from +R to 1i*R, the
# other from 1i*R to -R:

abs(integrate.segments(f,c(-R,R,1i*R))- answer.exact)


# Observe how much better one can do by integrating over a big square
# instead:

abs(integrate.segments(f,c(-R,R,R+1i*R, -R+1i*R))- answer.exact)


# Now in the interests of search engine findability, here is an
# application of Cauchy's integral formula, or Cauchy's formula.  I will
# use it to find sin(0.8):

u     &lt;- function(x){exp(pi*2i*x)}
udash &lt;- function(x){pi*2i*exp(pi*2i*x)}

g &lt;- function(z){sin(z)/(z-0.8)}

a &lt;- 1/(2i*pi)*integrate.contour(g,u,udash)


abs(a-sin(0.8))


</pre>

<hr /><div style="text-align: center;">[Package <em>elliptic</em> version 1.4-0 <a href="00Index.html">Index</a>]</div>
</body></html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Calculate e1, e2, e3 from the invariants</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for e1e2e3 {elliptic}"><tr><td>e1e2e3 {elliptic}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Calculate e1, e2, e3 from the invariants</h2>

<h3>Description</h3>

<p>Calculates <i>e1,e2,e3</i> from the invariants using
either <code>polyroot</code> or Cardano's method.
</p>


<h3>Usage</h3>

<pre>
e1e2e3(g, use.laurent=TRUE, AnS=is.double(g), Omega=NULL, tol=1e-6)
eee.cardano(g)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>g</code></td>
<td>
<p>Two-element vector with <code>g=c(g2,g3)</code></p>
</td></tr>
<tr valign="top"><td><code>use.laurent</code></td>
<td>
<p>Boolean, with default <code>TRUE</code> meaning
to use <code>P.laurent()</code> to determine the correct ordering for the
<i>e</i>: <i>P(omega1)</i>, <i>P(omega2)</i>,
<i>P(omega3)</i>.  Setting to  <code>FALSE</code> means to
return the solutions of the cubic equation directly: this is much
faster, but is not guaranteed to find the <i>e</i> in the
right order (the roots are found according to the vagaries of
<code>polyroot()</code>)</p>
</td></tr>
<tr valign="top"><td><code>AnS</code></td>
<td>
<p>Boolean, with default <code>TRUE</code> meaning to define
<i>omega3</i> as per ams-55, and <code>FALSE</code> meaning to
follow Whittaker and Watson, and define
<i>omega1</i> and <i>omega2</i> as the
primitive half periods, and
<i>omega3=-omega1-omega2</i>.  This is
also consistent with Chandrasekharan except the factor of 2.
</p>
<p>Also note that setting <code>AnS</code> to <code>TRUE</code> forces the
<i>e</i> to be real</p>
</td></tr>
<tr valign="top"><td><code>Omega</code></td>
<td>
<p>A pair of primitive half periods, if known.  If supplied, the
function uses them to calculate approximate values for the three
<i>e</i>s (but supplies values calculated by <code>polyroot()</code>,
which are much more accurate).  The function needs the approximate
values to determine in which order the <i>e</i>s should be, as
<code>polyroot()</code> returns roots in whichever order the polynomial
solver gives them in</p>
</td></tr>
<tr valign="top"><td><code>tol</code></td>
<td>
<p>Real, relative tolerance criterion for terminating Laurent
summation</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>Returns a three-element vector.
</p>


<h3>Note</h3>

<p>Function <code>parameters()</code> calls <code>e1e2e3()</code>, so <strong>do not
use <code>parameters()</code> to determine argument <code>g</code>, because
doing so will result in a recursive loop.</strong>
</p>
<p>Just to be specific: <code>e1e2e3(g=parameters(...))</code> will fail.  It
would be pointless anyway, because <code>parameters()</code> returns
(inter alia) <i>e1, e2, e3</i>.
</p>
<p>There is considerable confusion about the order of <i>e1</i>,
<i>e2</i> and <i>e3</i>, essentially due to Abramowitz and
Stegun's definition of the half periods being inconsistent with that
of Chandrasekharan's, and Mathematica's.  It is not possible to
reconcile A and S's notation for theta functions with
Chandrasekharan's definition of a primitive pair.  Thus,
the convention adopted here is the rather strange-seeming choice of
<i>e1=P(omega_1/2)</i>,
<i>e2=P(omega_3/2)</i>,
<i>e3=P(omega_2/2)</i>.  This has the advantage
of making equation 18.10.5 (p650, ams55), and equation
09.13.27.0011.01, return three identical values.
</p>
<p>The other scheme to rescue 18.10.5 would be to define
<i>(omega1,omega3)</i> as a primitive pair, and
to require
<i>omega2=-omega1-omega3</i>.  This is
the method adopted by Mathematica; it is no more inconsistent with
ams55 than the solution used in package <span class="pkg">elliptic</span>.  However,
this scheme suffers from the
disadvantage that the independent elements of <code>Omega</code> would
have to be supplied as <code>c(omega1,NA,omega3)</code>, and this is
inimical to the precepts of R.
</p>
<p>One can realize the above in practice by
considering what this package calls
&ldquo;<i>omega2</i>&rdquo; to be <em>really</em>
<i>omega3</i>, and what this package calls
&ldquo;<i>omega1+omega2</i>&rdquo; to be
<em>really</em> <i>omega2</i>.  Making function
<code>half.periods()</code> return a three element vector with names
<code>omega1</code>, <code>omega3</code>, <code>omega2</code> might work on some
levels, and indeed might be the correct solution for a user
somewhere; but it would be confusing.  This confusion would
dog my weary steps for ever more.    
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>Mathematica</p>


<h3>Examples</h3>

<pre>
 sum(e1e2e3(g=c(1,2)))
</pre>

<hr /><div style="text-align: center;">[Package <em>elliptic</em> version 1.4-0 <a href="00Index.html">Index</a>]</div>
</body></html>

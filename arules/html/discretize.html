<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Convert a Continuous Variable into a Categorical Variable</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for discretize {arules}"><tr><td>discretize {arules}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Convert a Continuous Variable into a Categorical Variable</h2>

<h3>Description</h3>

<p>This function implements several basic unsupervised methods to convert continuous variables into a categorical variables (factor) suitable for association rule mining. For convenience, a whole data.frame 
can be discretized (i.e., all numeric columns are discretized).
</p>


<h3>Usage</h3>

<pre>
discretize(x, method = "frequency", breaks = 3, 
  labels = NULL, include.lowest = TRUE, right = FALSE, dig.lab = 3,
  ordered_result = FALSE, infinity = FALSE, onlycuts = FALSE, 
  categories, ...)

discretizeDF(df, methods = NULL, default = NULL)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>a numeric vector (continuous variable).</p>
</td></tr>
<tr valign="top"><td><code>method</code></td>
<td>
<p> discretization method. Available are: <code>"interval"</code> (equal interval width), <code>"frequency"</code> (equal frequency), <code>"cluster"</code> (k-means clustering) and
<code>"fixed"</code> (categories specifies interval boundaries).
Note that equal frequency does not achieve perfect equally sized groups if the data contains duplicated values.</p>
</td></tr>
<tr valign="top"><td><code>breaks, categories</code></td>
<td>
 
<p><b><code>categories</code> is deprecated, use <code>breaks</code>.</b>
either number of categories or a vector with boundaries for 
discretization (all values outside the boundaries will be set to NA). </p>
</td></tr>
<tr valign="top"><td><code>labels</code></td>
<td>
<p> character vector; labels for the levels of the resulting category. By default, labels are constructed using &quot;(a,b]&quot; interval notation. If <code>labels = FALSE</code>, simple integer codes are returned instead of a factor..</p>
</td></tr>
<tr valign="top"><td><code>include.lowest</code></td>
<td>
<p> logical; should the first interval be closed to the left?</p>
</td></tr>
<tr valign="top"><td><code>right</code></td>
<td>
<p> logical; should the intervals be closed on the right (and open on the left) or vice versa?</p>
</td></tr>
<tr valign="top"><td><code>dig.lab</code></td>
<td>
<p> integer; number of digits used to create labels.</p>
</td></tr>
<tr valign="top"><td><code>ordered_result</code></td>
<td>
<p> logical; return a ordered factor? </p>
</td></tr>
<tr valign="top"><td><code>infinity</code></td>
<td>
<p> logical; should the first/last break boundary changed to 
+/-Inf? </p>
</td></tr>
<tr valign="top"><td><code>onlycuts</code></td>
<td>
<p> logical; return only computed interval boundaries? </p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>for method &quot;cluster&quot; further arguments are passed on to
<code>kmeans</code>. </p>
</td></tr></table>
<p>.
</p>
<table summary="R argblock">
<tr valign="top"><td><code>df</code></td>
<td>
<p>data.frame; each numeric column in the data.frame is discretized.</p>
</td></tr>
<tr valign="top"><td><code>methods</code></td>
<td>
<p>named list of lists or a data.frame; 
the named list contains list of discretization parameters 
(see parameters of <code>discretize</code>) for each numeric column
(see details). If no specific discretization is specified for a column,
then the default settings for <code>discretize</code> are used.
Note: the names have to match exactly.
If a data.frame is specified, then the discretization breaks in this 
data.frame are applied to <code>df</code>.</p>
</td></tr>
<tr valign="top"><td><code>default</code></td>
<td>
<p>named list; parameters for <code>discretize</code>
used for all columns not specified in <code>methods</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>discretize</code> only implements unsupervised discretization. See packages <span class="pkg">arulesCBA</span>, <span class="pkg">discretization</span> or <span class="pkg">RWeka</span> for supervised 
discretization.
</p>
<p><code>discretizeDF</code> applies discretization to each numeric column. 
Individual discretization parameters can be specified in the form:
<code>methods = list(column_name1 = list(method = ,...), column_name2 = list(...))</code>.
</p>


<h3>Value</h3>

<p>A factor representing the categorized continuous variable
with attribute <code>"discretized:breaks"</code> indicating the used breaks
or and <code>"discretized:method"</code> giving the used method. If 
<code>onlycuts = TRUE</code> is used, a vector with the calculated 
interval boundaries is returned.
</p>
<p><code>discretizeDF</code> returns a discretized data.frame.
</p>


<h3>Author(s)</h3>

<p>Michael Hahsler</p>


<h3>Examples</h3>

<pre>
data(iris)
x &lt;- iris[,1]

### look at the distribution before discretizing
hist(x, breaks = 20, main = "Data")

def.par &lt;- par(no.readonly = TRUE) # save default
layout(mat = rbind(1:2,3:4))

### convert continuous variables into categories (there are 3 types of flowers)
### the default method is equal frequency
table(discretize(x, breaks = 3))
hist(x, breaks = 20, main = "Equal Frequency")
abline(v = discretize(x, breaks = 3, 
  onlycuts = TRUE), col = "red")
# Note: the frequencies are not exactly equal because of ties in the data 

### equal interval width
table(discretize(x, method = "interval", breaks = 3))
hist(x, breaks = 20, main = "Equal Interval length")
abline(v = discretize(x, method = "interval", breaks = 3, 
  onlycuts = TRUE), col = "red")

### k-means clustering 
table(discretize(x, method = "cluster", breaks = 3))
hist(x, breaks = 20, main = "K-Means")
abline(v = discretize(x, method = "cluster", breaks = 3, 
  onlycuts = TRUE), col = "red")

### user-specified (with labels)
table(discretize(x, method = "fixed", breaks = c(-Inf, 6, Inf), 
    labels = c("small", "large")))
hist(x, breaks = 20, main = "Fixed")
abline(v = discretize(x, method = "fixed", breaks = c(-Inf, 6, Inf), 
    onlycuts = TRUE), col = "red")

par(def.par)  # reset to default

### prepare the iris data set for association rule mining
### use default discretization
irisDisc &lt;- discretizeDF(iris)
head(irisDisc)

### specify discretization for the petal columns
irisDisc &lt;- discretizeDF(iris, methods = list(
  Petal.Length = list(method = "frequency", breaks = 3, 
    labels = c("short", "medium", "long")),
  Petal.Width = list(method = "frequency", breaks = 2, 
    labels = c("narrow", "wide"))
  ))
head(irisDisc)

### discretize new data using the same discretization scheme as the
###   data.frame supplied in methods. Note: NAs may occure if a new 
###   value falls outside the range of values observed in the 
###   originally discretized table (use argument infinity = TRUE in 
###   discretize to prevent this case.) 
discretizeDF(iris[sample(1:nrow(iris), 5),], methods = irisDisc)
</pre>

<hr /><div style="text-align: center;">[Package <em>arules</em> version 1.6-1 <a href="00Index.html">Index</a>]</div>
</body></html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Enumerate the partitions of an integer</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for parts {partitions}"><tr><td>parts {partitions}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Enumerate the partitions of an integer</h2>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Given an integer, return a matrix whose columns enumerate various
partitions.
</p>
<p>Function <code>parts()</code> returns the unrestricted partitions; function
<code>diffparts()</code> returns the unequal partitions; function
<code>restrictedparts()</code> returns the restricted partitions; function
<code>blockparts()</code> returns the partitions subject to specified
maxima; and function <code>compositions()</code> returns all compositions
of the argument.
</p>


<h3>Usage</h3>

<pre>
parts(n)
diffparts(n)
restrictedparts(n, m, include.zero=TRUE, decreasing=TRUE)
blockparts(f, n=NULL, include.fewer=FALSE)
compositions(n, m=NULL, include.zero=TRUE)
multiset(v,n=length(v))
mset(v)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>n</code></td>
<td>
<p>Integer to be partitioned.  In function <code>blockparts()</code>,
the default of <code>NULL</code> means to return all partitions of any size</p>
</td></tr>
<tr valign="top"><td><code>m</code></td>
<td>
<p>In functions <code>restrictedparts()</code> and
<code>compositions()</code>, the order of the partition</p>
</td></tr>
<tr valign="top"><td><code>include.zero</code></td>
<td>
<p>In functions <code>restrictedparts()</code> and
<code>compositions()</code>, Boolean with default <code>FALSE</code> meaning to
include only partitions of <i>n</i> into <em>exactly</em> <i>m</i>
parts; and <code>TRUE</code> meaning to include partitions of <i>n</i> into
<em>at most</em> <i>m</i> parts (because zero parts are included)</p>
</td></tr>
<tr valign="top"><td><code>include.fewer</code></td>
<td>
<p>In function <code>blockparts()</code>, Boolean with
default <code>FALSE</code> meaning to return vectors whose sum is
<em>exactly</em> <code>n</code> and <code>TRUE</code> meaning to return partitions
whose sum is <em>at most</em> <code>n</code></p>
</td></tr>
<tr valign="top"><td><code>decreasing</code></td>
<td>
<p>In <code>restrictedparts()</code>, Boolean with default
<code>TRUE</code> meaning to return partitions whose parts are in
decreasing order and <code>FALSE</code> meaning to return partitions in
lexicographical order, as appearing in Hindenburg's
algorithm.   Note that setting to <code>decreasing</code> to <code>FALSE</code>
has the effect of making <code>conjugate()</code> return garbage</p>
</td></tr>
<tr valign="top"><td><code>f</code></td>
<td>
<p>In function <code>blockparts()</code>, a vector of strictly
positive integers that gives the maximal number of blocks; see
details</p>
</td></tr>
<tr valign="top"><td><code>v</code></td>
<td>
<p>In function <code>multiset()</code>, an integer vector representing
a multiset.  Argument <code>n</code> is the size of the sample to be taken</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> Function <code>parts()</code> uses the algorithm in Andrews.
Function <code>diffparts()</code> uses a very similar algorithm that I
have not seen elsewhere.  These functions behave strangely if given
an argument of zero.
</p>
</li>
<li><p> Function <code>restrictedparts()</code> uses the algorithm in
Andrews, originally due to Hindenburg.  For partitions into at most
<i>m</i> parts, the same Hindenburg's algorithm is used but with a
start vector of <code>c(rep(0,m-1),n)</code>.
</p>
<p>If \(m>n\), the partitions are padded with zeros.
</p>
</li>
<li><p> Function <code>blockparts()</code> enumerates the compositions of an
integer subject to a maximum criterion: given vector
\(y=(y_1,\ldots,y_n)\) all sets of
\(a=(a_1,\ldots,a_n)\) satisfying
\(\sum_{i=1}^pa_i=n\) subject to \(0\leq a_i\leq
    y_i\) for all <i>i</i> are given in lexicographical
order.  If argument <code>y</code> includes zero elements, these are
treated consistently (ie a position with zero capacity).
</p>
<p>If <code>n</code> takes its default value of <code>NULL</code>, then the
restriction \(\sum_{i=1}^pa_i=n\) is relaxed (so that
the numbers may sum to anything).  Note that these solutions are not
necessarily in standard form, so functions <code>durfee()</code> and
<code>conjugate()</code> may fail.
</p>
</li>
<li><p> With a single argument, <code>compositions(n)</code> returns
all \(2^{n-1}\) ways of partitioning an integer; thus
<code>4+1+1</code> is distinct from <code>1+4+1</code> or <code>1+1+4</code>.
</p>
<p>With two arguments, <code>compositions(n,m)</code> returns all
nonnegative solutions to \(x_1+\cdots+x_m=n\).
</p>
<p>This function is different from all the others in the package in
that it is written in <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>; it is not clear that C would be any
faster.
</p>
</li>
<li><p> Function <code>multiset()</code> returns all ways of ordering a
multiset (<code>mset()</code> is a low-level helper function).
</p>
</li></ul>

<pre>
&gt;  parts(7)
                                  
[1,] 7 6 5 5 4 4 4 3 3 3 3 2 2 2 1
[2,] 0 1 2 1 3 2 1 3 2 2 1 2 2 1 1
[3,] 0 0 0 1 0 1 1 1 2 1 1 2 1 1 1
[4,] 0 0 0 0 0 0 1 0 0 1 1 1 1 1 1
[5,] 0 0 0 0 0 0 0 0 0 0 1 0 1 1 1
[6,] 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1
[7,] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1
&gt; P(7)
[1] 15
&gt; diffparts(9)
                    
[1,] 9 8 7 6 6 5 5 4
[2,] 0 1 2 3 2 4 3 3
[3,] 0 0 0 0 1 0 1 2
&gt; Q(9)
[1] 8
&gt; restrictedparts(9,4)
                                        
[1,] 9 8 7 6 5 7 6 5 4 5 4 3 6 5 4 4 3 3
[2,] 0 1 2 3 4 1 2 3 4 2 3 3 1 2 3 2 3 2
[3,] 0 0 0 0 0 1 1 1 1 2 2 3 1 1 1 2 2 2
[4,] 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 2
&gt; R(4,9,include.zero=TRUE)
[1] 18
&gt; blockparts(1:4,5)
                                                
[1,] 1 1 0 1 1 0 1 0 1 1 0 1 0 0 1 0 1 0 0 1 0 0
[2,] 2 1 2 2 1 2 0 1 2 1 2 0 1 0 1 2 0 1 0 0 1 0
[3,] 2 3 3 1 2 2 3 3 0 1 1 2 2 3 0 0 1 1 2 0 0 1
[4,] 0 0 0 1 1 1 1 1 2 2 2 2 2 2 3 3 3 3 3 4 4 4
&gt; S(1:4,5)
[1] 22
&gt; compositions(5,3)
                                              
[1,] 5 4 3 2 1 0 4 3 2 1 0 3 2 1 0 2 1 0 1 0 0
[2,] 0 1 2 3 4 5 0 1 2 3 4 0 1 2 3 0 1 2 0 1 0
[3,] 0 0 0 0 0 0 1 1 1 1 1 2 2 2 2 3 3 3 4 4 5
&gt; S(rep(5,3),5)
[1] 21
&gt; setparts(4)
                                  
[1,] 1 1 1 1 2 1 1 1 1 1 1 2 2 2 1
[2,] 1 1 1 2 1 2 1 2 2 1 2 1 1 3 2
[3,] 1 2 1 1 1 2 2 1 3 2 1 3 1 1 3
[4,] 1 1 2 1 1 1 2 2 1 3 3 1 3 1 4
&gt;  setparts(c(1,2,2))
                                  
[1,] 1 1 1 1 1 1 1 1 1 1 1 1 3 3 3
[2,] 2 2 3 1 1 1 2 2 3 2 2 3 1 1 1
[3,] 3 2 2 3 2 2 1 1 1 3 2 2 2 1 2
[4,] 2 3 2 2 3 2 3 2 2 1 1 1 2 2 1
[5,] 1 1 1 2 2 3 2 3 2 2 3 2 1 2 2
</pre>


<h3>Note</h3>

<p>These vectorized functions return a matrix whose columns are the
partitions.  If this matrix is too large, consider enumerating the
partitions individually using the functionality documented in
<code>nextpart.Rd</code>.
</p>
<p>One commonly encountered idiom is <code>blockparts(rep(n,n),n)</code>, which
is equivalent to <code>compositions(n,n)</code> [Sloane's <code>A001700</code>].
</p>
<p>If you have a <em>minimum</em> number of balls in each block, a
construction like
</p>
<pre>
    x &lt;- c(1,1,2,1)   # min
    y &lt;- c(2,3,4,5)   # max
    
    sweep(blockparts(y-x,7-sum(x)),1,x,"+")
  </pre>
<p>can be helpful (that is, subtract off the minimum number of balls and
add them back again at the end). 
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>


<ul>
<li><p> G. E. Andrews. &ldquo;The theory of partitions&rdquo;,
Cambridge University Press, 1998
</p>
</li>
<li><p> R. K. S. Hankin 2006.  &ldquo;Additive integer partitions in
<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>&rdquo;. <em>Journal of Statistical Software</em>, Volume 16, code
snippet 1 
</p>
</li>
<li><p> R. K. S. Hankin 2007.  &ldquo;Urn sampling without
replacement: enumerative combinatorics in <span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>&rdquo;. <em>Journal of
Statistical Software</em>, Volume 17, code snippet 1
</p>
</li>
<li><p> R. K. S. Hankin 2007.  &ldquo;Set partitions in
<span style="font-family: Courier New, Courier; color: #666666;"><b>R</b></span>&rdquo;. <em>Journal of Statistical Software</em>, Volume
23, code snippet 2
</p>
</li>
<li><p> N. J. A. Sloane, 2008, The On-Line Encyclopedia of Integer
Sequences.  Sequence A001700
</p>
</li>
<li><p> D. Knuth, 2004.  The art of computer programming, pre-fascicle
2B &ldquo;Generating all permutations&rdquo;
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="nextpart.html">nextpart</a></code></p>


<h3>Examples</h3>

<pre>
parts(5)
diffparts(10)
matplot(t(diffparts(27)),type='l',lty=1)

restrictedparts(9,4)
restrictedparts(9,4,FALSE)
restrictedparts(9,4,decreasing=TRUE)

blockparts(1:4)
blockparts(1:4,3)
blockparts(1:4,3,include.fewer=TRUE)

blockparts(c(4,3,3,2),5)  # Knuth's example, pre-fascicle 3a, p16

compositions(4)           # not the same as parts(4)
compositions(4,4) 

# With 10 blocks, enumerate all partitions with maxima of 1:5 and minima
# of c(0,1,1,2,1):

a &lt;- c(0,1,1,2,1)
sweep(blockparts(1:5-a,10-sum(a)),1,a,"+")

#Knuth's example:
multiset(c(1,2,2,3))

multiset(rep(4+1:3,1:3),3)
</pre>

<hr /><div style="text-align: center;">[Package <em>partitions</em> version 1.10-1 <a href="00Index.html">Index</a>]</div>
</body></html>

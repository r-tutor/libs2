<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: data.tree: Hierarchical Data Structures</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for data.tree {data.tree}"><tr><td>data.tree {data.tree}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>data.tree: Hierarchical Data Structures</h2>

<h3>Description</h3>

<p><code>data.tree</code> is to hierarchical data what <code>data.frame</code> is to tabular data: An extensible, general purpose structure to store, manipulate, 
and display hierarchical data.
</p>


<h3>Introduction</h3>

<p>Hierarchical data is ubiquitous in statistics and programming (XML, search trees, family trees, classification, file system, etc.). However, no general-use <b>tree data structure</b> is available in R. 
Where tabular data has <code>data.frame</code>, hierarchical data is often modeled in lists of lists or similar makeshifts. These
structures are often difficult to manage.
This is where the <code>data.tree</code> package steps in. It lets you build trees of hierarchical
data for various uses: to print, to rapid prototype search algorithms, to test out new classification algorithms, and much more.
</p>


<h3>Tree Traversal</h3>

<p><code>data.tree</code> allows to <code><a href="Traverse.html">Traverse</a></code> trees in various orders (pre-order, post-order, level, etc.), and it lets you run operations on <code><a href="Node.html">Node</a>s</code> via
<code><a href="Do.html">Do</a></code>. 
Similarly, you can collect and store data while traversing a tree using the <code><a href="Get.html">Get</a></code> and the <code><a href="Set.html">Set</a></code> methods.
</p>


<h3>Methods</h3>

<p>The package also contains utility functions to <code><a href="Sort.html">Sort</a></code>, to <code><a href="Prune.html">Prune</a></code>, to <code><a href="Aggregate.html">Aggregate</a></code> and <code><a href="Cumulate.html">Cumulate</a></code> 
and to <code><a href="../../base/html/print.html">print</a></code> in custom formats.
</p>


<h3>Construction and Conversion</h3>

<p>The package also contains many conversions from and to data.tree structures. Check out the see also section of <code><a href="as.Node.html">as.Node</a></code>.
</p>
<p>You can construct a tree from a <code>data.frame</code> using <code><a href="as.Node.data.frame.html">as.Node.data.frame</a></code>, and convert it back using <code><a href="as.data.frame.Node.html">as.data.frame.Node</a></code>.
Similar options exist for list of lists. 
For more specialized conversions, see <code><a href="as.dendrogram.Node.html">as.dendrogram.Node</a></code>, <code><a href="as.Node.dendrogram.html">as.Node.dendrogram</a></code>, 
<code><a href="as.phylo.Node.html">as.phylo.Node</a></code> and <code><a href="as.Node.phylo.html">as.Node.phylo</a></code>
</p>
<p>Finally, easy conversion options from and to JSON, YAML, igraph, and more exist.
</p>


<h3>Node and Reference Semantics</h3>

<p>The entry point to the package is <code><a href="Node.html">Node</a></code>. Each tree is composed of a number of <code>Node</code>s, referencing each other.
</p>
<p>One of most important things to note about <code>data.tree</code> is that it exhibits <b>reference semantics</b>. In a nutshell, this means that you can modify 
your tree along the way, without having to reassign it to a variable after each modification. By and large, this is a rather exceptional behavior
in R, where value-semantics is king most of the time.
</p>


<h3>Applications</h3>

<p><code>data.tree</code> is not optimised for computational speed, but for implementation speed. Namely, its memory
footprint is relatively large compared to traditional R data structures. However, it can easily handle trees with
several thousand nodes, and once a tree is constructed, operations on it are relatively fast.
data.tree is always useful when
</p>

<ul>
<li><p>you want to develop and test a new algorithm
</p>
</li>
<li><p>you want to import and convert tree structures (it imports and exports to list-of-list, data.frame, yaml, json, igraph, dendrogram, phylo and more)
</p>
</li>
<li><p>you want to play around with data, display it and get an understanding
</p>
</li>
<li><p>you want to test another package, to compare it with your own results
</p>
</li>
<li><p>you need to do homework
</p>
</li></ul>

<p>For a quick overview of the features, read the <code><a href="data.tree.html">data.tree</a></code> vignette by running <code>vignette("data.tree")</code>. For stylized
applications, see <code>vignette("applications", package='data.tree')</code>
</p>


<h3>See Also</h3>

<p><code><a href="Node.html">Node</a></code>
</p>
<p>For more details, see the <code>data.tree</code> vignette by running: <code>vignette("data.tree")</code>
</p>


<h3>Examples</h3>

<pre>
data(acme)
print(acme)
acme$fieldsAll
acme$count
acme$totalCount
acme$isRoot
acme$height
print(acme, "p", "cost")

outsource &lt;- acme$IT$Outsource
class(outsource)
print(outsource)
outsource$fields
outsource$isLeaf
outsource$level
outsource$path
outsource$p
outsource$parent$name
outsource$root$name
outsource$expCost &lt;- outsource$p * outsource$cost
print(acme, "expCost")

acme$Get("p")
acme$Do(function(x) x$expCost &lt;- x$p * x$cost)
acme$Get("expCost", filterFun = isLeaf)

ToDataFrameTable(acme, "name", "p", "cost", "level", "pathString")
ToDataFrameTree(acme, "name", "p", "cost", "level")
ToDataFrameNetwork(acme, "p", "cost")


</pre>

<hr /><div style="text-align: center;">[Package <em>data.tree</em> version 0.7.4 <a href="00Index.html">Index</a>]</div>
</body></html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Apply a Trained Data Recipe</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for bake {recipes}"><tr><td>bake {recipes}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Apply a Trained Data Recipe</h2>

<h3>Description</h3>

<p>For a recipe with at least one preprocessing operation that has been trained by
<code><a href="prep.html">prep.recipe()</a></code>, apply the computations to new data.
</p>


<h3>Usage</h3>

<pre>
bake(object, ...)

## S3 method for class 'recipe'
bake(object, new_data, ..., composition = "tibble")
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>object</code></td>
<td>
<p>A trained object such as a <code><a href="recipe.html">recipe()</a></code> with at least
one preprocessing operation.</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>One or more selector functions to choose which variables will be
returned by the function. See <code><a href="selections.html">selections()</a></code> for more details.
If no selectors are given, the default is to use
<code><a href="../../dplyr/html/reexports.html">everything()</a></code>.</p>
</td></tr>
<tr valign="top"><td><code>new_data</code></td>
<td>
<p>A data frame or tibble for whom the preprocessing will be
applied. If <code>NULL</code> is given to <code>new_data</code>, the pre-processed <em>training
data</em> will be returned (assuming that <code>prep(retain = TRUE)</code> was used).</p>
</td></tr>
<tr valign="top"><td><code>composition</code></td>
<td>
<p>Either &quot;tibble&quot;, &quot;matrix&quot;, &quot;data.frame&quot;, or
&quot;dgCMatrix&quot; for the format of the processed data set. Note that
all computations during the baking process are done in a
non-sparse format. Also, note that this argument should be
called <strong>after</strong> any selectors and the selectors should only
resolve to numeric columns (otherwise an error is thrown).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="bake.html">bake()</a></code> takes a trained recipe and applies the
operations to a data set to create a design matrix.
</p>
<p>If the data set is not too large, time can be saved by using the
<code>retain = TRUE</code> option of <code><a href="prep.html">prep()</a></code>. This stores the processed version of the
training set. With this option set, <code>bake(object, new_data = NULL)</code>
will return it for free.
</p>
<p>Also, any steps with <code>skip = TRUE</code> will not be applied to the
data when <code>bake()</code> is invoked with a data set in <code>new_data</code>.
<code>bake(object, new_data = NULL)</code> will always have all of the steps applied.
</p>


<h3>Value</h3>

<p>A tibble, matrix, or sparse matrix that may have different
columns than the original columns in <code>new_data</code>.
</p>


<h3>Author(s)</h3>

<p>Max Kuhn
</p>


<h3>See Also</h3>

<p><code><a href="recipe.html">recipe()</a></code>, <code><a href="prep.html">prep()</a></code>
</p>


<h3>Examples</h3>

<pre>
data(ames, package = "modeldata")

ames &lt;- mutate(ames, Sale_Price = log10(Sale_Price))

ames_rec &lt;-
  recipe(Sale_Price ~ ., data = ames[-(1:6), ]) %&gt;%
  step_other(Neighborhood, threshold = 0.05) %&gt;%
  step_dummy(all_nominal()) %&gt;%
  step_interact(~ starts_with("Central_Air"):Year_Built) %&gt;%
  step_ns(Longitude, Latitude, deg_free = 2) %&gt;%
  step_zv(all_predictors()) %&gt;%
  prep()

# return the training set (already embedded in ames_rec)
ames_train &lt;- bake(ames_rec, new_data = NULL)

# apply processing to other data:
ames_new &lt;- bake(ames_rec, new_data = head(ames))
</pre>

<hr /><div style="text-align: center;">[Package <em>recipes</em> version 0.1.15 <a href="00Index.html">Index</a>]</div>
</body></html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Create a Recipe for Preprocessing Data</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for recipe {recipes}"><tr><td>recipe {recipes}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Create a Recipe for Preprocessing Data</h2>

<h3>Description</h3>

<p>A recipe is a description of what steps should be applied to a data set in
order to get it ready for data analysis.
</p>


<h3>Usage</h3>

<pre>
recipe(x, ...)

## Default S3 method:
recipe(x, ...)

## S3 method for class 'data.frame'
recipe(x, formula = NULL, ..., vars = NULL, roles = NULL)

## S3 method for class 'formula'
recipe(formula, data, ...)

## S3 method for class 'matrix'
recipe(x, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x, data</code></td>
<td>
<p>A data frame or tibble of the <em>template</em> data set
(see below).</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>Further arguments passed to or from other methods (not currently
used).</p>
</td></tr>
<tr valign="top"><td><code>formula</code></td>
<td>
<p>A model formula. No in-line functions should be used here
(e.g. <code>log(x)</code>, <code>x:y</code>, etc.) and minus signs are not allowed. These types of
transformations should be enacted using <code>step</code> functions in this package.
Dots are allowed as are simple multivariate outcome terms (i.e. no need for
<code>cbind</code>; see Examples).</p>
</td></tr>
<tr valign="top"><td><code>vars</code></td>
<td>
<p>A character string of column names corresponding to variables
that will be used in any context (see below)</p>
</td></tr>
<tr valign="top"><td><code>roles</code></td>
<td>
<p>A character string (the same length of <code>vars</code>) that
describes a single role that the variable will take. This value could be
anything but common roles are <code>"outcome"</code>, <code>"predictor"</code>,
<code>"case_weight"</code>, or <code>"ID"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Recipes are alternative methods for creating design matrices and
for preprocessing data.
</p>
<p>Variables in recipes can have any type of <em>role</em> in subsequent analyses
such as: outcome, predictor, case weights, stratification variables, etc.
</p>
<p><code>recipe</code> objects can be created in several ways. If the analysis only
contains outcomes and predictors, the simplest way to create one is to use
a simple formula (e.g. <code>y ~ x1 + x2</code>) that does not contain inline
functions such as <code>log(x3)</code>. An example is given below.
</p>
<p>Alternatively, a <code>recipe</code> object can be created by first specifying
which variables in a data set should be used and then sequentially
defining their roles (see the last example).
</p>
<p>There are two different types of operations that can be
sequentially added to a recipe. <strong>Steps</strong>  can include common
operations like logging a variable, creating dummy variables or
interactions and so on. More computationally complex actions
such as dimension reduction or imputation can also be specified.
<strong>Checks</strong> are operations that conduct specific tests of the
data. When the test is satisfied, the data are returned without
issue or modification. Otherwise, any error is thrown.
</p>
<p>Once a recipe has been defined, the <code><a href="prep.html">prep()</a></code> function can be
used to estimate quantities required for the operations using a
data set (a.k.a. the training data). <code><a href="prep.html">prep()</a></code> returns another
recipe.
</p>
<p>To apply the recipe to a data set, the <code><a href="bake.html">bake()</a></code> function is
used in the same manner as <code>predict</code> would be for models. This
applies the steps to any data set.
</p>
<p>Note that the data passed to <code>recipe</code> need not be the complete data
that will be used to train the steps (by <code><a href="prep.html">prep()</a></code>). The recipe
only needs to know the names and types of data that will be used. For
large data sets, <code>head</code> could be used to pass the recipe a smaller
data set to save time and memory.
</p>


<h3>Value</h3>

<p>An object of class <code>recipe</code> with sub-objects:
</p>
<table summary="R valueblock">
<tr valign="top"><td><code>var_info</code></td>
<td>
<p>A tibble containing information about the original data
set columns</p>
</td></tr>
<tr valign="top"><td><code>term_info</code></td>
<td>
<p>A tibble that contains the current set of terms in the
data set. This initially defaults to the same data contained in
<code>var_info</code>.</p>
</td></tr>
<tr valign="top"><td><code>steps</code></td>
<td>
<p>A list of <code>step</code>  or <code>check</code> objects that define the sequence of
preprocessing operations that will be applied to data. The default value is
<code>NULL</code></p>
</td></tr>
<tr valign="top"><td><code>template</code></td>
<td>
<p>A tibble of the data. This is initialized to be the same
as the data given in the <code>data</code> argument but can be different after
the recipe is trained.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Max Kuhn
</p>


<h3>Examples</h3>

<pre>

###############################################
# simple example:
library(modeldata)
data(biomass)

# split data
biomass_tr &lt;- biomass[biomass$dataset == "Training",]
biomass_te &lt;- biomass[biomass$dataset == "Testing",]

# When only predictors and outcomes, a simplified formula can be used.
rec &lt;- recipe(HHV ~ carbon + hydrogen + oxygen + nitrogen + sulfur,
              data = biomass_tr)

# Now add preprocessing steps to the recipe.

sp_signed &lt;- rec %&gt;%
  step_normalize(all_predictors()) %&gt;%
  step_spatialsign(all_predictors())
sp_signed

# now estimate required parameters
sp_signed_trained &lt;- prep(sp_signed, training = biomass_tr)
sp_signed_trained

# apply the preprocessing to a data set
test_set_values &lt;- bake(sp_signed_trained, new_data = biomass_te)

# or use pipes for the entire workflow:
rec &lt;- biomass_tr %&gt;%
  recipe(HHV ~ carbon + hydrogen + oxygen + nitrogen + sulfur) %&gt;%
  step_normalize(all_predictors()) %&gt;%
  step_spatialsign(all_predictors())

###############################################
# multivariate example

# no need for `cbind(carbon, hydrogen)` for left-hand side
multi_y &lt;- recipe(carbon + hydrogen ~ oxygen + nitrogen + sulfur,
                  data = biomass_tr)
multi_y &lt;- multi_y %&gt;%
  step_center(all_outcomes()) %&gt;%
  step_scale(all_predictors())

multi_y_trained &lt;- prep(multi_y, training = biomass_tr)

results &lt;- bake(multi_y_trained, biomass_te)

###############################################
# Creating a recipe manually with different roles

rec &lt;- recipe(biomass_tr) %&gt;%
  update_role(carbon, hydrogen, oxygen, nitrogen, sulfur,
           new_role = "predictor") %&gt;%
  update_role(HHV, new_role = "outcome") %&gt;%
  update_role(sample, new_role = "id variable") %&gt;%
  update_role(dataset, new_role = "splitting indicator")
rec
</pre>

<hr /><div style="text-align: center;">[Package <em>recipes</em> version 0.1.15 <a href="00Index.html">Index</a>]</div>
</body></html>

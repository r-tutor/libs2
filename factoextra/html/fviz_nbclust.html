<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Dertermining and Visualizing the Optimal Number of Clusters</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for fviz_nbclust {factoextra}"><tr><td>fviz_nbclust {factoextra}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Dertermining and Visualizing the Optimal Number of Clusters</h2>

<h3>Description</h3>

<p>Partitioning methods, such as k-means clustering require the 
users to specify the number of clusters to be generated. </p>
 
<ul>
<li><p>fviz_nbclust(): Dertemines and visualize the optimal number of 
clusters using different methods: <strong>within cluster sums of squares</strong>, 
<strong>average silhouette</strong> and <strong>gap statistics</strong>.  
</p>
</li>
<li><p>fviz_gap_stat(): Visualize the gap statistic generated by the 
function <code><a href="../../cluster/html/clusGap.html">clusGap</a></code>() [in cluster package]. The optimal
number of clusters is specified using the &quot;firstmax&quot; method 
(?cluster::clustGap). </p>
</li></ul>

<p>Read more: 
<a href="http://www.sthda.com/english/wiki/determining-the-optimal-number-of-clusters-3-must-known-methods-unsupervised-machine-learning">Determining
the optimal number of clusters</a>
</p>


<h3>Usage</h3>

<pre>
fviz_nbclust(x, FUNcluster = NULL, method = c("silhouette", "wss",
  "gap_stat"), diss = NULL, k.max = 10, nboot = 100,
  verbose = interactive(), barfill = "steelblue",
  barcolor = "steelblue", linecolor = "steelblue",
  print.summary = TRUE, ...)

fviz_gap_stat(gap_stat, linecolor = "steelblue", maxSE = list(method =
  "firstSEmax", SE.factor = 1))
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
<p>numeric matrix or data frame. In the function fviz_nbclust(), x can 
be the results of the function NbClust().</p>
</td></tr>
<tr valign="top"><td><code>FUNcluster</code></td>
<td>
<p>a partitioning function which accepts as first argument a 
(data) matrix like x, second argument, say k, k &gt;= 2, the number of 
clusters desired, and returns a list with a component named cluster which 
contains the grouping of observations. Allowed values include: kmeans,
cluster::pam, cluster::clara, cluster::fanny, hcut, etc. This argument is
not required when x is an output of the function 
<code><a href="../../NbClust/html/NbClust.html">NbClust</a></code>().</p>
</td></tr>
<tr valign="top"><td><code>method</code></td>
<td>
<p>the method to be used for estimating the optimal number of 
clusters. Possible values are &quot;silhouette&quot; (for average silhouette width), 
&quot;wss&quot; (for total within sum of square) and &quot;gap_stat&quot; (for gap statistics).</p>
</td></tr>
<tr valign="top"><td><code>diss</code></td>
<td>
<p>dist object as produced by dist(), i.e.: diss = dist(x, method = 
&quot;euclidean&quot;). Used to compute the average silhouette width of clusters, the
within sum of square and hierarchical clustering. If NULL, dist(x) is 
computed with the default method = &quot;euclidean&quot;</p>
</td></tr>
<tr valign="top"><td><code>k.max</code></td>
<td>
<p>the maximum number of clusters to consider, must be at least two.</p>
</td></tr>
<tr valign="top"><td><code>nboot</code></td>
<td>
<p>integer, number of Monte Carlo (&quot;bootstrap&quot;) samples. Used only for determining the number of clusters 
using gap statistic.</p>
</td></tr>
<tr valign="top"><td><code>verbose</code></td>
<td>
<p>logical value. If TRUE, the result of progress is printed.</p>
</td></tr>
<tr valign="top"><td><code>barfill, barcolor</code></td>
<td>
<p>fill color and outline color for bars</p>
</td></tr>
<tr valign="top"><td><code>linecolor</code></td>
<td>
<p>color for lines</p>
</td></tr>
<tr valign="top"><td><code>print.summary</code></td>
<td>
<p>logical value. If true, the optimal number of clusters 
are printed in fviz_nbclust().</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>optionally further arguments for FUNcluster()</p>
</td></tr>
<tr valign="top"><td><code>gap_stat</code></td>
<td>
<p>an object of class &quot;clusGap&quot; returned by the function
clusGap() [in cluster package]</p>
</td></tr>
<tr valign="top"><td><code>maxSE</code></td>
<td>
<p>a list containing the parameters (method and SE.factor) for
determining the location of the maximum of the gap statistic (Read the
documentation ?cluster::maxSE). Allowed values for maxSE$method include: 
</p>
 <ul>
<li><p> &quot;globalmax&quot;: simply corresponds to the global maximum,
i.e., is which.max(gap) </p>
</li>
<li><p> &quot;firstmax&quot;: gives the location of the first
local maximum </p>
</li>
<li><p> &quot;Tibs2001SEmax&quot;: uses the criterion, Tibshirani et al
(2001) proposed: &quot;the smallest k such that gap(k) &gt;= gap(k+1) - s_k+1&quot;. 
It's also possible to use &quot;the smallest k such that gap(k) &gt;= gap(k+1) -
SE.factor*s_k+1&quot; where SE.factor is a numeric value which can be 1
(default), 2, 3, etc. </p>
</li>
<li><p> &quot;firstSEmax&quot;: location of the first f() value
which is not larger than the first local maximum minus SE.factor * SE.f[],
i.e, within an &quot;f S.E.&quot; range of that maximum. </p>
</li>
<li>
<p>see ?cluster::maxSE for more options </p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

 <ul>
<li><p> fviz_nbclust, fviz_gap_stat: return a ggplot2 </p>
</li></ul>



<h3>Author(s)</h3>

<p>Alboukadel Kassambara <a href="mailto:alboukadel.kassambara@gmail.com">alboukadel.kassambara@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="fviz_cluster.html">fviz_cluster</a></code>, <code><a href="eclust.html">eclust</a></code>
</p>


<h3>Examples</h3>

<pre>
set.seed(123)

# Data preparation
# +++++++++++++++
data("iris")
head(iris)
# Remove species column (5) and scale the data
iris.scaled &lt;- scale(iris[, -5])


# Optimal number of clusters in the data
# ++++++++++++++++++++++++++++++++++++++
# Examples are provided only for kmeans, but
# you can also use cluster::pam (for pam) or
#  hcut (for hierarchical clustering)
 
### Elbow method (look at the knee)
# Elbow method for kmeans
fviz_nbclust(iris.scaled, kmeans, method = "wss") +
geom_vline(xintercept = 3, linetype = 2)

# Average silhouette for kmeans
fviz_nbclust(iris.scaled, kmeans, method = "silhouette")

### Gap statistic
library(cluster)
set.seed(123)
# Compute gap statistic for kmeans
# we used B = 10 for demo. Recommended value is ~500
gap_stat &lt;- clusGap(iris.scaled, FUN = kmeans, nstart = 25,
 K.max = 10, B = 10)
 print(gap_stat, method = "firstmax")
fviz_gap_stat(gap_stat)
 
# Gap statistic for hierarchical clustering
gap_stat &lt;- clusGap(iris.scaled, FUN = hcut, K.max = 10, B = 10)
fviz_gap_stat(gap_stat)

 
</pre>

<hr /><div style="text-align: center;">[Package <em>factoextra</em> version 1.0.6 <a href="00Index.html">Index</a>]</div>
</body></html>
